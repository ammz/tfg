#+OPTIONS: author:nil
#+OPTIONS: title:nil
#+OPTIONS: date:nil
#+OPTIONS: toc:nil
# #+OPTIONS: num:nil
#+LANGUAGE: es
#+OPTIONS: ':t
#+OPTIONS: H:5
# #+EXPORT_FILE_NAME: ../tex/borrador
#+LATEX_CLASS: etea-empty
#+bibliography: references.bib
#+CITE_EXPORT: biblatex numeric
#+LaTeX_HEADER: \input{~/Sync/proyectos/tfg/tex/tfg-conf.tex}


* Portada                                                            :ignore:

#+BEGIN_SRC latex
    \begin{titlepage}
      \begin{sffamily}
        % \color{azulon}
        \begin{center}
          \begin{figure}
            \makebox[\textwidth][c]{\includegraphics[width=8cm]{logo-uloyola.png}}
          \end{figure}
          \vspace{2.5cm}
          {\Large Grado en Ingeniería Informática y Tecnologías Virtuales}\\
          \vspace{2cm}
          {\Large Trabajo Fin de Grado}
          \rule{10.5cm}{0.1mm}\\
          \bigskip
          {\Huge Simulación de fluidos}\\[10pt]
          {\Huge basada en física}\\[10pt]
          {\Huge utilizando la arquitectura CUDA}
          \vspace*{0.5cm}
          \rule{10.5cm}{0.1mm}\\
          \vspace*{0.9cm}
          {\large Autor}\\
          {\Large Antonio Moreno Talero}\\
          \vspace*{1cm}
          {\large Tutor}\\
          {\Large Juan J. Perea Rodríguez}
          \vfill
          {\large Sevilla, febrero 2023}
        \end{center}
        \color{black}
      \end{sffamily}
  \end{titlepage}

  \newpage
  \thispagestyle{empty}
  \mbox{}
  \newpage
#+END_SRC


* Contenido                                                          :ignore:

#+BEGIN_SRC latex
  \frontmatter
  \tableofcontents
  \listoffigures
  \mainmatter
#+END_SRC


* Introducción


La computación gráfica o gráficos por ordenador también conocida por sus siglas en ingles CG (/Computer Graphics/) es el campo de la informática que trata de la generación y procesamiento de imágenes y gráficos mediante el uso de algoritmos y técnicas de programación. En la actualidad, es una tecnología clave para multitud de sectores, que van desde el cine, la fotografía digital, los videojuegos hasta la investigación científica, la arquitectura, la medicina o el diseño de vehículos.

El proyecto desarrollado para este Trabajo de Fin de Grado se centra en el uso de la metodología de generación de imágenes mediante un proceso de simulación. En concreto, se plantea una simulación basada en física, también designada como simulación dinámica.

La simulación de un sistema dinámico implica resolver las complejas ecuaciones en derivadas parciales con las que se describe, cuantitativamente, su comportamiento. Para llevar a cabo esta tarea, es necesario utilizar métodos numéricos que transforman esas complejas ecuaciones diferenciales en un conjunto de ecuaciones algebraicas, relativamente más sencillas de manejar e implementables en sistemas computacionales.

De forma aún más específica este proyecto se centrará en la simulación del comportamiento de los fluidos. La simulación de fluidos es una técnica utilizada en la ingeniería y la ciencia para modelar y predecir el comportamiento de la dinámica de medios contínuos, como los flujos de un fluido, en un sistema determinado. Se utiliza en una gran variedad de aplicaciones, como la simulación de procesos industriales, el diseño de aeronaves, vehículos e incluso en la predicción meteorológica.

Para que estas técnicas puedan ser utilizadas es necesario modelar la continuidad del fluido en un conjunto discreto de /entidades/ conexas.

Entre los diferentes métodos numéricos que se han desarrollado, merecen destacar, por su extenso uso: el Método de Elementos Finitos o FEM (del inglés /Finite Element Method/), el Método de los Volúmenes Discretos o DVM (del inglés /Discrete Volume Method/) o /Particles in cell/ (PIC), en la que las /entidades/ conexas son polígonos conexos que forman una malla, y el método Smoothed Particles Hydrodynamics (SPH) en el que las entidades son partículas libres que se /conectan/ directamente a través de funciones contínuas decrecientes. Este último método es el que vamos a utilizar en nuestro proyecto.

Si se realizará una descripción más específica en el Capítulo 2, seguidamente se describen  algunas de las características más generales del método SPH.

** (Navier Stokes)                                                  :ignore:

La dinámica de un fluido se refiere al comportamiento del fluido y a su evolución en el espacio y el tiempo. Esto también implica dar respuesta a cómo el fluido se mueve, cómo cambia de forma o cómo cambian sus propiedades físicas.

Una de las principales ecuaciones que rigen la dinámica de los fluidos es la ecuación de Navier-Stokes, que describe cómo la velocidad, la presión y la densidad del fluido cambian con el tiempo y el espacio. Esta ecuación se basa en las ecuaciones de conservación de masa y movimiento, y tiene en cuenta factores como la viscosidad, las fuerzas externas y la inercia del fluido.

Igualmente, la dinámica de un fluido también se ve afectada por la /estratificación/, que es cuando las diferentes capas de un fluido tienen distintas velocidades debido a diferencias en las propiedades del fluido, como la densidad o la viscosidad. Esto puede dar lugar a distintos fenómenos como los remolinos o las corrientes de remolino.

Otro factor importante en la dinámica de los fluidos es la turbulencia, que es el movimiento caótico e irregular de un fluido. La turbulencia puede estar causada por factores como las diferencias de velocidad, las irregularidades en la superficie o las perturbaciones externas. El factor de la turbulencia puede tener un gran impacto en la dinámica de un fluido, ya que puede aumentar la mezcla y el intercambio de calor y masa.

En resumen, la dinámica de un fluido se refiere al comportamiento y evolución del fluido en el espacio y el tiempo, y está determinada por una serie de factores como las ecuaciones de conservación de masa y movimiento, la viscosidad, las fuerzas externas, la estratificación y la turbulencia.

Para describir completamente la dinámica del fluido se requiere de hasta nueve ecuaciones en derivadas parciales. No obstante, distintos estudios sugieren la pertinencia de prescindir de un gran número de ellas, y centrarse en la ecuación obtenida a partir de la conservación del  momento. Es por ello, que se utiliza la denominada ecuación de Navier--Stokes ([[ec:Navier--Stokes]]) que en su forma más compacta se puede expresar como sigue:
#
#+NAME: ec:Navier--Stokes
\begin{gather}
\rho\frac{\mathrm {D} v}{\mathrm {D} t} = -\nabla P + \nu\nabla^2 v + \rho g
\end{gather}
#
@@latex:\noindent@@ donde
$\rho$ es la densidad del fluido, $\frac{\mathrm {D}}{\mathrm {D} t}$ es la derivada sustancial, $v$ es la velocidad del flujo del fluido, $P$ es la presión del fluido, $g$ es la gravedad y $\nu$ es la viscosidad del fluido.

Esta ecuación expresa el comportamiento del fluido y su dinámica, describiendo cómo la velocidad, la presión y la densidad evolucionan en el tiempo y en el espacio.

Aunque es indudable las ventajas que representa poder operar exclusivamente con la ecuación de Navier--Stokes en la simulación de fluidos, algunos autores han apuntado que precisamente en la simulación de fluidos, es conveniente incorporar la propiedad de /incompresibilidad/, sobre todo en el ámbito de la CG, ya que esta no está considerada en la ecuación de Navier--Stokes. Ha habido distintas propuestas técnicas que pretenden resolver el problema /imponiendo/ la incompresiblidad mediante procesos de adaptación de resultados calculando el valor instantáneo de la presión o a través de la composición de la ecuación de Navier--Stokes y la conservación de la masa. Debido a estas desventajas, en este proyecto consideraremos un modelo basado em la propuesta de Perea et al. [42] que impone implícitamente la incompresibilidad.

** Diferentes métodos numéricos

Simular un fluido implica resolver las complejas ecuaciones en derivadas parciales con las que se describe, cuantitativamente, el flujo del fluido. Para llevar a cabo esta tarea, es necesario utilizar métodos numéricos que transformen esas complejas ecuaciones diferenciales en un conjunto de ecuaciones algebraicas, relativamente más sencillas de manejar.

Existen varios métodos numéricos que se han desarrollado para la simulación de fluidos, y se pueden clasificar según su tipología en dos grupos principales:

- *Métodos Eulerianos*

  Se trata de métodos en los que se considera el fluido como un medio continuo (mallas, generalmente de triángulos o cuadriláteros, en el caso de bi–dimensional o bien, hexaedros o tetraedros, para el caso tridimensional) y se describen las variables en un punto fijo del espacio y el tiempo. Entre estos métodos se encuentran el método de volúmenes finitos o FEM (del inglés /Finite Element Method/) y el método de diferencias finitas o FDM (del inglés /Finite Difference Method/). Ambos métodos se basan en la discretización del espacio y del tiempo y se utilizan para resolver ecuaciones diferenciales. Son ampliamente utilizados para simular el comportamiento de fluidos incompresibles y compresibles, especialmente en casos donde hay un gran número de obstáculos o geometrías complejas.


- *Métodos Lagrangianos*:

  Son aquellos métodos en los que se considera el fluido como un conjunto de partículas y se describen las variables en función de la posición y la velocidad de cada partícula. El método de partículas (SPH) es un ejemplo de estos métodos, se basa en la resolución de la ecuación de continuidad y la ecuación de movimiento para cada partícula, utilizando una función de suavizado o kernel para la interpolación entre las partículas. Este método es ampliamente utilizado en aplicaciones como la simulación de fluidos en medios porosos, fluidos multi-componentes y en problemas de dinámica de fluidos complejos.

  Los métodos lagrangianos presentan indudables ventajas frente a los eulerianos, ya que, por una parte, al operar con partículas en lugar de mallas permite una mayor simplificación de los cálculos y permite una gran adaptabilidad al contenedor del fluido, especialmente cuando se simulan líquidos. Por otro lado, resolver la ecuación de Navier--Stoke mediante el uso de técnicas lagrangianas, “genera” un conjunto de ecuaciones desacopladas que facilita el proceso de solución. Otra importante característica de los métodos lagrangianos  es que facilitan simular la interfase entre fluidos –por ejemplo aire–líquido– y la conservación de la masa, cómo se ha demostrado por (...)

EL SPH (/Smoothed Particle Hydrodynamics/) se presenta como el método más destacable de los métodos lagrangianos. Se trata método numérico utilizado para simular el comportamiento de fluidos. En este método, el fluido se representa como un conjunto de partículas que se mueven e interactúan entre sí a través de fuerzas de interacción, definido a partir de las ecuaciones en derivadas parciales con las que se describe el flujo del fluido. Cada partícula tiene una masa y está sujeta a la influencia de las demás partículas, las más próximas, a su alrededor. Esta interacción local es la que modela la interacción y permite reproducir el comportamiento de los fluidos de manera realista. Dado los buenos resultados que ofrece, el método SPH se utiliza a menudo en aplicaciones de simulación de fluidos en la industria del cine y en la ingeniería, así como en la investigación científica.

Algunas de las ventajas específicas asociadas al uso del método SPH son las siguientes:

- Simplicidad de implementación: SPH es relativamente fácil de implementar y requiere poca información previa sobre el sistema que se está simulando.

- Flexibilidad: SPH es un método muy flexible que se puede utilizar en una amplia variedad de aplicaciones y escenarios.

- Capacidad de manejar flujos no newtonianos: SPH es capaz de manejar flujos no newtonianos, lo que lo hace adecuado para la simulación de fluidos con comportamientos no lineales.

- Robustez: SPH es un método robusto que puede manejar cambios bruscos en el flujo y en la topología del sistema.

- Facilidad de paralelización: SPH es fácil de paralelizar lo que permite acelerar la simulación en máquinas con varios núcleos o en /clusters/ de computación.

A pesar de estas ventajas, el método SPH tiene algunos problemas asociados que hace que aún sea un campo de investigación en desarrollo. Algunas de las desventajas que este método presenta son:

- Dificultad para manejar obstáculos sólidos: uno de los principales problemas de SPH es la dificultad para manejar obstáculos sólidos de manera efectiva. Esto puede dar lugar a penetraciones de partículas a través de los obstáculos lo que afecta al realismo de la simulación.

- Pérdida de precisión en la modelización de ondas: SPH tiende a tener dificultades para reproducir ondas de alta frecuencia y amplitud, lo que puede afectar la precisión de la simulación en algunos casos. El resultado es la aparición de atenuación de este tipo de ondas lo que induce sobreamortiguamiento poco realista.

- Dificultad para manejar flujos de alta velocidad: SPH puede tener problemas para manejar flujos de alta velocidad debido a la discretización de las partículas y a la forma en que se calculan las fuerzas de interacción entre ellas.

- Sensibilidad a los parámetros de entrada: el rendimiento de SPH puede ser sensible a los parámetros de entrada, lo que puede hacer difícil encontrar los valores óptimos para una simulación determinada.

- Altos requisitos computacionales: debido a la gran cantidad de partículas involucradas en las simulaciones de SPH, este método puede requerir una gran cantidad de recursos de cómputo para su ejecución, especialmente a la hora de determinar las partículas más próximas a cada una de ellas, las /partículas vecinas/, que son con las que interactúa.

** Objetivos

El principal objetivo de este trabajo es desarrollar un simulador tridimensional que sea capaz de simular el comportamiento de un fluido de manera realista y conseguir alcanzar el máximo rendimiento posible utilizando el lenguaje de programación CUDA que permite programar en las GPUs de NVIDIA de manera relativamente sencilla y paralelizar los cálculos de SPH, tales como la búsqueda de partículas vecinas y la actualización de sus posiciones y velocidades, conseguiendo una mayor velocidad en la obtención de estos resultados.

En el desarrollo del proyecto también se ha investigado en solventar los principales inconvenientes que tiene el método SPH, en analizar los diferentes parámetros dentro de la simulación para que la simulación sea estable y estudiar otras propuestas, en desarrollar una implementación que nos permita colisionar de manera realista con diferentes tipos de solidos rígidos y en implementar exportadores para motores de renderizado para que el proyecto tenga un renderizado de mayor calidad

El proyecto deberá tener una estructura que sea escalable ya que no se pretende que este proyecto, dado lo ambicioso de sus objetivos, no es finalizar dentro del tiempo dado durante el TFG si no que se desarrolle más allá del ámbito de la universidad.


** Organización del proyecto

El presente documento se divide en ocho capítulos, en los cuales se explica el contenido de la investigación, la experimentación realizada, así como los resultados obtenidos durante su transcurso:

En el capítulo 2 se describirá de manera técnica el proyecto a desarrollar y se enumerarán los requisitos que debe cumplir el trabajo y las herramientas utilizadas en el proceso de desarrollo.

En el capítulo 3 se revisara en profundidad el método SPH, especialemente en sus fundamentos matemáticos, los diferentes estudios que avalan el método y los problemas del mismo junto con las diferentes soluciones creadas para solventarlos.

En el capítulo 4 se explican los diferentes métodos de integración temporal, uno de los pilares en la simulación, qué papel juega dentro de nuestra simulación y se explica la decisión de escoger un método sobre otro.

En el capítulo 5 se discute brevemente una de las dificultades del método SPH: la reacción ante obstáculos, y como se ha resuelto la problemática desarrollando un gestor de colisiones.

En el capítulo 6 se detallan las características del lenguaje CUDA, indicando los motivos de su elección y las ventajas e inconvenientes que presenta. También se explica brevemente la librería gráfica OpenGL. Esta librería se utilizó en un principio para visualizar el comportamiento de la simulación de manera gráfica, aunque posteriormente se ha cambiado por un /exportador,/ que directamente exporta los datos de las partículas para un renderizado en un programa comercial: RealFlow.

En el capítulo 7 se lleva a cabo la descripción de cómo se ha implantado todo lo explicado anteriormente y la estructura del simulador. Además se presentan los resultados obtenidos.

Finalmente, en el capítulo 8 se muestran las conclusiones obtenidas a partir de los resultados y se exponen las diferentes ampliaciones y posibilidades que tiene este proyecto en el futuro.

* Análisis

** Introducción

En este segundo capítulo explicaremos todo lo concerniente al estudio previo desarrollado para la aplicación (en nuestro caso una simulación) solicitado. Se describirá de manera técnica, se enumeraran los requisitos que se deben cumplir en la aplicación, los objetivos durante la duración del proyecto y las herramientas necesarias.

** Definición del problema real

Se solicita una simulación de fluidos que se comporte de manera realista y tenga un enfoque académico junto con un análisis de resultado para comparar con otras propuestas realizadas en estudios parecidos.

** Análisis de requisitos

*** Funcionamiento

Se definen las funcionalidades que se integran en el proyecto.

La funcionalidad de la simulación es la simulación en si misma además de cumplir con los estándares de los considerado realista en el ámbito de las Computer Graphics junto con una mejora de rendimiento.

*** Entorno:

- Entorno Software: El desarrollo se lleva a cabo dentro del editor visual Studio 2019 ya que cuenta con la integración de la librería CUDA.

- Entorno Hardware: El programa se podrá utilizar en sistemas operativos Windows con tarjetas graficas NVIDIA que tengan compatibilidad con la versión de CUDA que se este utilizando

- Entorno de Usuario: Aunque los resultados de la simulación pueden ser apreciados por cualquier tipo de persona, este proyecto esta orientado a personas con conocimientos previos de computación paralela y la simulación física

*** Vida Esperada:

Al ser un proyecto de investigación con vistas de mejora a futuro es difícil concretar la vida esperada de la aplicación. También debido a que estamos usando tecnología dependiente de NVIDIA, esta simulación será funcional mientras sigan manteniendo las librerías.

*** Ciclo de mantenimiento:

En una segunda etapa de experimentación, elmarco de predicción propuesto ha sido instanciado en un caso de concreto y real, donde ha sido adaptado para el análisis de flujos de tráfico entrates.

La aplicación tendrá que ser revisada para posibles mejoras debido a las nuevas versiones de CUDA o nuevas investigaciones que puedan arrojar posibilidades para obtener mejores resultados.

Aunque sin esto la aplicación seguirá siendo funcional no estará al día con los nuevos avances.

*** Competencia
Los diversos estudios de simulación que se presentan en el SIGGRAPH cada año.

*** Aspecto externo:

** Planificación y seguimiento
* Fundamentos del Método SPH
** Introducción

En la introducción de esta memoria de TFG, describimos las características generales de las magnitudes dinámicas y constitutivas del fluido. También expusimos las complejidades que tiene resolver de la ecuación dinámica del fluido, la ecuación [[ec:Navier--Stokes]], y la imposibilidad de resolverla, en la mayoría de los casos, mediante técnicas analíticas. La consecuencia de esta limitación es la necesidad del uso de técnicas numéricas. Así mismo, esbozamos la metodología lagrangiana que utilizamos en este proyecto para simular el flujo del fluido, concretamente, el método Smoothed Particles Hydrodynamics (SPH).

En este capítulo vamos a concretar las características generales y los fundamentos en los que se basa SPH. Además, describiremos los problemas de estabilidad que pueden presentar los resultados obtenidos mediante SPH. Problemas que hemos considerado para evitarlos y obtener simulaciones realistas en diferentes entorno de simulación.

Si bien el método SPH fue desarrollado por Gingold--Monaghan [cite:@Gingold-Monaghan77] y Lucy [cite:@Lucy77], para la simulación de sistemas de múltiples cuerpos, como ocurre en cosmología, rápidamente fue adaptado para sumular las ecuaciones dinámicas asociadas a medios continuos.  Específicamente, la formulación desarrollada por Gingold--Monaghan [cite:@Gingold-Monaghan77], es la que se utilizó para modelar las ecuaciones en derivadas parciales del fluido.

Para poder aplicar el método SPH en la simulación del flujo del fluido, es necesario que el continuo que es el fluido, quede representado, unívocamente, por un sistema de partículas que puedan interactuar entre cada una de ellas. Así pues, para una correcta representación del fluido mediante partículas, se tiene que cumplir que la suma de la masa de todas las partículas sea igual a la masa de la totalidad del fluido. Así queda satisfecha una de las restricciones más importantes en física que es \textit{la conservación de la masa}.  Una vez que el fluido es transformado en un sistema de partículas, se tiene que \textit{modelar} la interacción entre las partículas. Aquí es donde entra en juego la formulación de SPH, que describiremos a lo largo de este capítulo, con las que se modela las ecuaciones en derivadas parciales del fluido. Resumidamente, las dos \textit{piedras angulares} de SPH son:

1. /Las partículas/ donde se particularizan las magnitudes del fluido ($\rho$,$\nu$...), la masa y las magnitudes dinámicas (posición, velocidad, aceleración).

2. /La función para modelar la interacción/, que en el ámbito de SPH, suele denominarse /función kernel/. Esta función debe satisfacer ciertas condiciones, que describiremos posteriormente en este mismo capítulo, entre las que destaca la continuidad, su dependencia de la distancia y que esta dependencia es de monótona decreciente con la distancia, tal como se indica en [cite:@Liu-Liu03].

Visualmente, lo que acabamos de describir se ilustra en la figura \ref{fig:esquemaKernel}

# \begin{figure}[htbp!]
# 	\centering
# 	\includegraphics[scale=2.5]{Capitulo2/figuras2/SPH_1.eps}
# 	\caption{Ilustración de los pilares en los que se asienta el método SPH: partículas y función kernel. La interación está restringida por el dominio de la función, cuyo radio es $h$. Las partículas que cumplan que su distancia es inferior a $h$, se denominan partículas vecinas.}
# 	\label{fig:esquemaKernel}
# \end{figure}

Una vez que hemos descrito brevemente los pilares fundamentales del método SPH, seguidamente vamos a llevar a cabo una descripción más precisa. En la sección [[*Fundamentos del Método SPH]] vamos a llevar a cabo la definición de las características generales, enunciadas por Monaghan et al. [cite:@Gingold-Monaghan77] y Lucy [cite:@Lucy77] en sus primeras propuestas, y ampliada a lo largo de las últimas décadas. A continuación, se establecerán las formulaciones matemáticas con las que se modelan las ecuaciones del fluido. Para finalizar el capítulo se establecerán las principales limitaciones que presenta SPH y que son consideradas a la hora de implementar la simulación del fluido planificada en este proyecto.

** Fundamentos del Método SPH

El método SPH, según se ha explicado en la sección [[*Introducción]], tiene dos pilares fundamentales, estos son: las partículas y las funciones kernel. Sobre cada una de las partículas, con las que se modela el fluido en para utilizar SPH, se definen cada una de las magnitudes necesarias para resolver la ecuación NS --ecuación [[ec:Navier--Stokes]]--, es decir, la velocidad, la presión, la densidad y la masa. Además, sobre cada una de las partículas se define una función kernel que ``\textit{pondera}'' cada una de esas magnitudes dinámicas, a partir del valor que tienen dichas magnitudes en sus partículas más próximas. Modelar un fluido mediante partículas que no está ligadas a través a una malla implica que el movimiento de las partículas sea el flujo del fluido. Debido a este hecho, se puede afirmar que SPH es un método lagrangiano.

Desde un punto de vista numérico, cuando el fluido es modelado mediante partículas, y sus magnitudes se aproximan mediante SPH, la ecuación de NS se transforma en un conjunto de ecuaciones algebraicas que no están acopladas entre sí. Este desacoplamiento es gracias a la formulación de la función kernel. Según se afirma en Liu et al. [cite:@Liu-Liu03], esta formulación reduce el coste computacional y simplifica los cálculos si se compara con el modelado basado en mallas. No obstante, Price [cite:@Price12] advierte de que el número de partículas vecinas $j$, de cada una de las partículas $i$, debe ser relativamente alto, en un rango mínimo de $80-120$. Sin embargo, dependiendo del tipo de función kernel, y más concretamente de su formulación, este rango de valores puede disminuir, tal como se indica en [cite:@Price12; @Perea-Cordero16]. Así pues, se puede afirmar que las características analíticas condiciona la calidad de la simulación.

Existe un consenso en relacionar las características analíticas de las diferentes funciones kernel, con la estabilidad y el realismo. A este respecto, se han llevado a cabo una gran cantidad de estudios que establecen cuales deben ser las características esenciales, que una función monótona decreciente, debe satisfacer para obtener simulaciones de fluido realistas. La primera función kernel fue propuesta por Monaghan et al. [cite:@Monaghan92; @Gingold-Monaghan77] y se trata de la función exponencial. Esta función puede proporcionar resultados adecuados, pero presenta una incompatibilidad, que es el hecho de que su radio de dominio soportado $h$ es infinito y dado este valor establece el número de partículas vecinas, se tendría un alto número, lo cual dificulta el cálculo de las magnitudes dinámicas del fluido, como es destacado en [cite:@Liu-Liu03].

Además de la limitación destacada por Liu et al. [cite:@Liu-Liu03], se han desarrollado diversos estudios que establecen las características que hacen a cualquier función monótona decreciente una ``\textit{buena}'' función kernel. Estos estudios son:


1. Fulk et al. [cite:@Fulk94] establece que el dominio de definición de la función kernel debe ser cerrado y acotado y además su decrecimiento debe ser suave.

2. Otro estudio muy destacado es el llevado a cabo por Cappuzzo et al. [cite:@Capuzzo-DiLisio00] en el que se afirma que la función kernel debe ser una función positiva que induzca también un valor positivo de la densidad de masa.

3. \label{punto:punto2} Dehnen et al. [cite:@Dehnen-Aly12] centra su estudio no sólo en la función kernel, sino también en las características que debe presentar la primera derivada de la función kernel. Según Dehnen  la función kernel debe ser una función par y su gradiente, con el que se obtiene la fuerza de presión en la ecuación [[ec:Navier--Stokes]], debe tener un valor nulo en el origen, es decir, en la posición de la partícula.

4. De las investigaciones desarrolladas por Cabezón [cite:@CabGarRel08], Price [cite:@Price12] y Dehnen et al. [cite:@Dehnen-Aly12], se deduce que la mejor función kernel debería ser continua e infinitamente diferenciable, lo que el matemática analítica se denomina $\mathcal{C}^{\infty}$.

Otras características que tiene el método SPH, que representan una ventaja cualitativa a lo hora de llevar a cabo la simulación son:

1. \emph{La conservación de la masa} que es posible porque la masa de cada partícula  $m_{p_{i}}$, representa una fracción de la masa total del fluido, es decir $\sum_i m_{p_{i}} = M_f$, donde $M_f$ representa la masa total del fluido. La principal ventaja es que considerando exclusivamente la ecuación de NS es posible simular el fluido, tal como se desataca en [cite:@Monaghan92; @Liu-Liu03].

2. \emph{Permite definir el límite liquido--aire}, conocida también como superficie libre, en el ámbito de CG [cite:@MulChaGro03] es consecuencia del modelado a través de partículas. Esta característica representa una clara ventaja frente a los modelos basados en mallas, como destaca [cite:@AkiIhmAkin.etal12].

3. \emph{No requiere de la implementación del término de advección.} Por tratarse SPH de una técnica lagrangiana, y el hecho de que las partículas se desplazan con el flujo del fluido, no se debe considerar el término de advección, según se explica en [cite:@Liu-Liu03].

4. \emph{La ecuación de NS se transforma en un conjunto de ecuaciones algebraicas desacopladas.} Comparativamente con los métodos basados en mallas esto representa una ventaja ya que no hay que resolver complejos sistemas de ecuaciones a la hora de implementar la simulación del fluido mediante SPH [cite:@Liu-Liu03]. Esta ventaja es muy importante si se desea paralelizar el cálculo de la dinámica del fluido.

5. \emph{Simplifica las colisiones del fluido con el contorno}, como describiremos en el capítulo [[*Colisiones]] de esta memoria de proyecto. Se debe a que es más fácil calcular la colisión partícula contorno del cuerpo rígido que la colisión entre diferentes mallas, tal como se indica en [cite:@MulChaGro03].

No obstante, aunque SPH presenta las ventajas que acabamos de describir, puede generar inestabilidades en las simulaciones que afecten a su realismo. Esta limitación se hace muy visible cuando la cantidad de partículas vecinas es baja, entorno a $20$, tal como destaca Yan et al. [cite:@YanPenLiu14]. La complejidad de diseñar una función kernel que evite este problema es una tarea compleja que sale fuera de los objetivos de este proyecto. En este proyecto utilizaremos la propuesta de Perea et al. [cite:@Perea-Cordero18; @Perea-Cordero16] donde se desarrolla un estudio de estabilidad y precisión en simulaciones de fluido mediante SPH y formulan una función kernel que garantiza buenos resultados aunque el número de partículas vecinas sea bajo.

Tras esta breve introducción al método SPH, el resto del capítulo de organiza del siguiente modo. En la sección [[*Fundamentos del Método SPH]] vamos a llevar a cabo una descripción de los fundamentos de SPH, tal como las definión Monaghan et al. [cite:@Gingold-Monaghan77] y Lucy [cite:@Lucy77]. Seguidamente, en la sección [[*Fundamentos de SPH y su Formulación]] expondremos cómo quedan las ecuaciones dinámicas del fluido modeladas mediante la formulación SPH. Así mismo, expondremos como se obtienen las ecuaciones discretas, que utilizaremos en nuestro simulador, y como éstas se obtienen a partir de la formulación integral, que es el punto de partida que desarrolló Monaghan et al. [cite:@Gingold-Monaghan77]. El proceso seguido en la descripción es el propuesto por Monaghan [cite:@Monaghan82; @monaghan1992smoothed], Liu [cite:@Liu-Liu03] y Price [cite:@Price12].

** Fundamentos de SPH y su Formulación

Desde la perspectiva de análisis funcional, tal como se describe en [cite:@Liu-Liu03], el método SPH se sitúa dentro de la denominada convolución funcional. Expresándola en otros términos, la convolución permite que cualquier función desconocida pueda calcularse a partir de la combinación de funciones conocidas (que en el ámbito de SPH son las ya mencionadas funciones kernel). A pesar de que este es el fundamento que permite operar con funciones conocidas, para obtener la solución desconocida de las ecuaciones en derivadas parciales que describen la dinámica del fluido, el origen del método SPH, tal como lo establecieron Monaghan [cite:@Gingold-Monaghan77] y Lucy [cite:@Lucy77], difiere en parte. El punto de partida es desarrollar una formulación integral de una función incógnita, para posteriormente formular su expresión discreta, que será la utilizada en el sistema de partículas que modela el fluido a simular. Según esta ``visión'', Monaghan estableció que la formulación integral de cualquier función incógnita, se puede obtener siguiendo el mismo criterio establecido por Dirac para formular la denominada función $\delta$ de Dirac.

Existe un consenso en descomponer, en dos etapas, las operaciones con las que Monaghan [cite:@Gingold-Monaghan77] establece la ecuación fundamental de SPH acorde con el criterio establecido por Dirac para formular su función $\delta$:

1. \label{punto:paso1Cap2FormIntegral} La primera etapa se basa en considerar, tal como estableció Dirac, la formulación integral de la función  $\delta$, pero considerando que se trata, en lugar de una pulsiana, de una función cerrada y acotada, lo que el análisis de funciones se conoce como \textit{función compacta}, con un dominio espacial mayor que el de $\delta$. Llegados este punto, merece la pena destacar que esa función compacta, con la que se ``sustituye'' a $\delta$, es la función kernel de SPH, que será descrita con mayor profundidad en la sección [[*Fundamentos del Método SPH]]. De este modo, Monaghan establece la formulación integral del método SPH.

2. \label{punto:paso2Cap2FormDiscreta} En la segunda etapa se opera sobre la formulación integral desarrollada en la primera etapa, para transformarla en una expresión discreta, esto es, transformar la integral en sumatoria. De este modo, las ecuaciones obtenidas pueden ser aplicadas sobre un sistema discreto como, por ejemplo, es el sistema de partículas con el que se modela el fluido a simular. Por ello, son estas ecuaciones discretas las que utilizaremos en nuestro simulador.

En las próximas subsecciones [[*Formulación integral de las ecuaciones del método SPH]] y [[*Formulación discreta de las ecuaciones del método SPH]] llevaremos a cabo una descripción más exhaustiva de las dos etapas que, brevemente, acabamos de describir. En dichas secciones vamos a seguir las líneas establecidas por [cite:@monaghan1992smoothed; @AkiIhmAkin.etal12].

*** Formulación integral de las ecuaciones del método SPH

Esta sección se corresponde con la primera etapa, es decir, con la etapa \ref{punto:paso1Cap2FormIntegral}. Según formuló Monaghan [cite:@Gingold-Monaghan77], a partir de la función $\delta$ de Dirac, cualquier función desconocida  $f$ la expresa en términos de \ref{ec:deltaDirac}:

\begin{equation}\label{ec:deltaDirac}
f(r)=\int f(r')\delta(r-r')dr',
\end{equation}
donde $f$ hace referencia a la función desconocida, $r$ es a la posición, $r'$ es la posición de cualquier punto dentro del dominio de definición de $f$ y $\delta$ es la función de Dirac.

El siguiente paso seguido por Monaghan [cite:@monaghan1992smoothed; @Gingold-Monaghan77] es sustituir la función $\delta$ por una función con extensión espacial. Haciendo ese se obtiene la ecuación fundamental del método SPH. La expresión obtenida es \ref{ec:kernelIntegral}.

\begin{equation}\label{ec:kernelIntegral}
\tilde{f}(r)=\int_{\Omega} f(r')W(r-r',h)dr'
\end{equation}
donde  $(\tilde{})$ se utiliza para indicar que $\tilde{f}(r)$ es el valor aproximado de $f(r)$, $W$ es la función con extensión espacial que sustituye a la función $\delta$, la que en SPH se denomina \textit{función kernel}, $\Omega$ es el volumen de definición de $W$ y $h$ es el radio  de dicho dominio de definición, que en el ámbito de SPH se conoce como \textit{radio del dominio soportado}.

Puede deducirse que  la función $W$ de la ecuación \ref{ec:kernelIntegral}, la función kernel, es fundamental en SPH. ``\textit{A priori}'' cabría esperar que cualquier función compacta podría jugar el papel de función kernel, sin embargo, existe un conjunto de características, las cuales serán descritas posteriormente, que la función debe cumplir. Monaghan [cite:@Monaghan92], establece que, al menos, la función kernel debe satisfacer los siguientes criterios:

1. \label{punto:SPH_1} Cualquier función $W$ candidata a ser función kernel, debe estar normalizada y cuando el radio del dominio soportado $h$ tienda a cero, $W$ debe ser una función pulsiana como es la $\delta$ de Dirac, es decir:

   \begin{equation}\label{ec:condNormalizacion}
   \int_\Omega W dr' = 1
   \;\;\;\;\mbox{y}\;\;\;\;\lim_{h\rightarrow 0} W(r-r',h) = \delta(r-r').
   \end{equation}

2. \label{punto:SPH_3} $W$ tiene que ser compacta, es decir, debe ser una función serrada y acotada. Además, Monaghan sugiere que debe ser una función par, es decir, simétrica respecto del origen y decaer suavemente con la distancia.

Cabe destacar que la elección de la función kernel, es uno de los problemas recurrentes en el ámbito de SPH. Una buena elección, sobre todo cuando el número de partículas vecinas es relativamente bajo, garantiza resultados precisos y, por lo tanto, simulaciones realistas. Existen diferentes estudios en los que se analizan las características que debe cumplir una función compacta y simétrica para ser una buena función kernel. Merece destacar los estudios de Dehnen et al. [cite:@Dehnen-Aly12] y Yan et al. [cite:@YanPenLiu14] donde, además, hace una exposición de como controlar el error cometido. Sin embargo, realizar un estudio de las diferentes funciones kernel, queda fuera del ámbito de este capítulo, en el que describimos los fundamentos del método SPH.

*** Formulación integral de las derivadas de las ecuaciones de SPH

Una vez expuesta la formulación integral de SPH, el siguiente paso es ``adaptar'' esa formulación a la ecuación dinámica del fluido, es decir, la ecuación NS [[ec:Navier--Stokes]]. Por lo tanto, es necesario exponer la formulación del gradiente y el laplaciano, en términos de la ecuación \ref{ec:kernelIntegral}, ya que son las funciones que intervienen en la ecuación NS. Siguiendo los términos expuestos en [cite:@Liu-Liu03], se obtiene la ecuación \ref{ec:SPH11}:

\begin{equation}\label{ec:SPH11}
\nabla \cdot \tilde{f}(r)=\int_{\Omega}
\left[
\nabla\cdot f(r')
\right]W(r-r',h)dr',
\end{equation}
donde la expresión $\left[\nabla\cdot f(r')\right]$  se particulariza en $r'$ dentro del dominio soportado de $f$.

Para calcular el integrando de la ecuación \ref{ec:SPH11}, Monaghan [cite:@Monaghan92] hace uso de la regla de la cadena. Con esta operación la ecuación \ref{ec:SPH11} se transforma en la ecuación:

\begin{equation}\label{ec:SPH12}
\left[\nabla \cdot f(r')\right] W(r-r',h)=
\nabla\cdot\left[f(r') W(r-r',h)\right]-
f(r')\cdot \nabla\left[ W(r-r',h)\right],
\end{equation}

Sustituyendo la ecuación \ref{ec:SPH12} en \ref{ec:SPH11}, se obtiene la expresión del gradiente en términos de SPH, la ecuación que se obtiene es la expresión  \ref{ec:SPH13}:

\begin{equation}\label{ec:SPH13}
\nabla\cdot \tilde{f}(r)= \int_{\Omega}
\nabla\cdot\left[f(r')W(r-r',h)\right]dr'-
\int_{\Omega}
f(r')\cdot\nabla\left[W(r-r',h)\right]dr'.
\end{equation}

Tal como se indica en [cite:@Liu-Liu03], la ecuación \ref{ec:SPH13} es válida para calcular el gradiente de cualquier función. Sin embargo, para dotar de significado, se recomienda tener dos componente, una referida al volumen del dominio soportado y otro, específicamente, asociado al contorno. Expresándolo, en otros términos, en [cite:@Liu-Liu03], se recomienda que haya una componente de volumétrica y otra superficial (la asociada al contorno). Para que ello se cumpla, se hace uso del  \emph{Teorema de la Divergencia}, de este modo la ecuación \ref{ec:SPH13} se expresa en términos de la ecuación \ref{ec:SPH14}.

\begin{equation}\label{ec:SPH14}
\nabla\cdot \tilde{f}(r)= \int_{S}
f(r')W(r-r',h)\cdot \vec{n}dS-
\int_{\Omega}
f(r')\cdot\nabla\left[W(r-r',h)\right]dr'.
\end{equation}
donde $\vec{n}$ es el vector normal de la superficie que recubre el dominio $\Omega$.

La descomposición en dos componentes, una superficial y otra volumétrica, de la ecuación \ref{ec:SPH13} para obtener la ecuación \ref{ec:SPH14}, tiene un objetivo claro, tal como se indica en [cite:@Liu-Liu03], y es que si la función es compacta y el dominio soportado no ``penetra'' en los límites del fluido, por ejemplo en el contenedor en el que se encuentre confinado el fluido a simular, entonces la parte superficial de la ecuación \ref{ec:SPH14} se anula, por lo que se simplifica en términos de:
\begin{equation}\label{ec:SPH15}
\nabla\cdot \tilde{f}(r)=-\int_{\Omega}
f(r')\cdot\nabla\left[W(r-r',h)\right]dr'.
\end{equation}

# %Cabe destacar que si la condición de compacidad no es satisfecha entonces la %ecuación \ref{ec:SPH15} no es adecuada para obtener la aproximación $\nabla\cdot %\tilde{f}(r)$.

Siempre que se cumplan las condiciones para obtener la ecuación \ref{ec:SPH15}, se puede comprobar que el gradiente simplemente se obtiene como el producto de la función kernel por la función incógnita $f$, con lo que se simplifican los cálculos de las ecuaciones en derivadas parciales donde se utilicen, lo cual representa una ventaja operativa respecto de otras técnicas, como destaca Monaghan [cite:@Monaghan92].

En este proyecto vamos a utilizar funciones compactas, con lo que podemos utilizar las ecuaciones que se obtengan a partir de la expresión \ref{ec:SPH15}.


Para obtener ecuaciones diferenciales de orden superior, en Liu [cite:@Liu-Liu03], se propone extrapolar la ecuación \ref{ec:SPH15},para cualquier orden diferencial. Según su propuesta, la ecuación general que permitirá aproximar cualquier ecuación diferencial se expresa en términos de \ref{ec:SPHDerivadasGENERAL}:


\begin{equation}\label{ec:SPHDerivadasGENERAL}
\nabla ^l \tilde{f}(r)=-\int_{\Omega}
f(r')\cdot\nabla^l\left[W(r-r',h)\right]dr'.
\end{equation}
donde con $l$ se hace referencia al orden diferencial, p.e. $l=1$ será el gradiente y $l=2$ será el laplaciano.

*** Formulación discreta de las ecuaciones del método SPH

Mediante las ecuaciones \ref{ec:kernelIntegral}--\ref{ec:SPH15}, se tienen las expresiones con las que es posible transformar, analíticamente, las ecuaciones en derivadas parciales, con las que se describe el fluido, en términos del método SPH. Sin embargo, tal como se ha dicho previamente, estas ecuaciones no se pueden aplicar sobre un sistema discretizado, como es el sistema de partículas con el que se modela el fluido a simular. Para poder aplicar las expresiones \ref{ec:kernelIntegral}--\ref{ec:SPH15} a un sistema discreto, es necesario transformar dichas ecuaciones. Sucintamente, el proceso consiste en transformar las integrales, por sumatorias, restringidas a las partículas. En los estudios de [cite:@Price12; @Monaghan92], se describe el proceso clave que permite dicha trasformación y consiste en considerar que, cada una  de las partículas, representa una fracción del fluido, visto como un continuo, cuyo valor es  $\rho dV$. Teniendo en cuenta esta hipótesis es posible transformar la expresión \ref{ec:kernelIntegral} en la ecuación \ref{ec:spHAproximada}:

\begin{equation}\label{ec:spHAproximada}
 \tilde{f}(r_i) =\sum_{j\in\mathcal{N}(i)}\frac{m_j}{\rho_{j}}f(x_j) W(r_i-r_j,h),
\end{equation}
donde $\mathcal{N}(i)$ son las partículas vecinas de la partícula $i$, cuya cantidad viene condicionada por el valor del radio de dominio soportado, $h$.

Formulada la ecuación discreta con la que se aproxima la dunción $f$, el siguiente paso es formular las ecuaciones del gradiente. Siguiendo una línea de razonamiento análogo para obtener \ref{ec:spHAproximada}, Liu [cite:@Liu-Liu03] describe que la ecuación de partida es \ref{ec:gradientePre}.

\begin{equation}\label{ec:gradientePre}
\nabla \cdot \tilde{f}(r)=\int_{\Omega}
\left[
\nabla\cdot f(r')
\right]W(r-r',h)dr'=
\frac{\partial}{\partial r}\int \frac{f(r')}{\rho(r')}W(r-r',h)\rho(r')dr'
\end{equation}

A partir de la ecuación \ref{ec:gradientePre}, considerando que $f$ es compacta y no intersecta los límites del fluido, la ecuación \ref{ec:gradientePre} se reduce en términos de la ecuación \ref{ec:gradiente}:

\begin{equation}\label{ec:gradiente}
\nabla \tilde{f}(r)=\frac{\partial}{\partial r}\int \frac{f(r')}{\rho(r')}W(r-r',h)\rho(r')dr'\approx
\sum_{j\in\mathcal{N}(i)}m_j\frac{f_j}{\rho_j}\nabla W(r_j-r_i,h).
\end{equation}

Operando sobre la expresión \ref{ec:gradiente}, con el objetivo de obtener una ecuación similar a la expresión \ref{ec:SPH15}. En Liu [cite:@Liu-Liu03] se concluye que la ecuación discreta con la que es posible calcular la ecuación discreta para calcular el gradiente, que se expresa en términos de :

\begin{equation}\label{ec:SPH17}
\nabla\cdot \tilde{f}(r_i)=-\sum_{j\in\mathcal{N}(i)} \frac{m_j}{\rho_{j}}f(r_j)\cdot \nabla W(r_i-r_j,h),
\end{equation}
donde $\nabla W$ es la función kernel que se particulariza sobre cada una de las  $i$ partículas en las que se ha discretizado el fluido a simular.

Teniendo en cuenta la ecuación \ref{ec:SPH17}, y considerando la condición de compacidad, se puede obtener la ecuación discreta para calcular la derivada parcial para cualquier orden diferencial. La expresión que permite hacer ese cálculo es:

\begin{equation}\label{ec:deDerivadaDiscreta}
\nabla^l\cdot \tilde{f} (r)=-\sum_{j\in\mathcal{N}(i)} \frac{m_j}{\rho_{j}}f(r_j)\cdot \nabla^l W(r-r_j,h),
\end{equation}

Las expresiones obtenidas permite simplificar el cálculo de las complejas ecuaciones que describen la dinámica del fluido. Sin embargo, estas ecuaciones presentan dos importantes limitaciones:

1. Que la función kernel debe ser compacta y la partícula $i$, sobre las que se particulariza cada función kernel, deben estar lejos del contorno del fluido.

2. Las ecuaciones \ref{ec:deDerivadaDiscreta}, particularizadas para cada $l$, no satisfacen la conservación del momento, tal como advierten [cite:@Price12; @Monaghan92]. Para solventar este problema Monaghan [cite:@Monaghan92] propone el desarrollo de ecuaciones simétricas basadas en la regla de la cadena. El proceso que Monaghan sigue se describirá a continuación.

*** Formulación simétricas de las derivadas de las ecuaciones en SPH

Tal como se ha mencionado en la sección anterior, las ecuaciones discretas del método SPH obtenidas, aunque cumplen los criterios analíticos, nos satisfacen la conservación del momento, es decir, no satisface en principio acción--reacción. Monaghan [cite:@Monaghan92] advierte de este hecho y propone una metodología, basada en la regla de la cadena, para obtener ecuaciones simétricas que satisfagan dicha ley de conservación. Las ecuaciones que permiten simetrizar las derivadas parciales de las funciones desconocidas son \ref{ec:SPH18} y \ref{ec:SPH19}:

\begin{equation}\label{ec:SPH18}
\nabla^l f(r)=\frac{1}{\rho}\left[
\nabla^l \left(\rho f(r)\right)-
f(r)\nabla^l \rho
\right],
\end{equation}

\begin{equation}\label{ec:SPH19}
\nabla^l f(r)=\rho\left[
\nabla^l\left(\frac{f(r)}{\rho}\right)+
\frac{f(r)}{\rho^2}\nabla^l\rho
\right].
\end{equation}
donde $\rho$ hace referencia a la densidad de masa.

# %Las dos identidades anteriores pueden sustituirse por la integral en (11).


Análogamente a como se hizo para calcular la  ecuación \ref{ec:SPH17}, se puede operar sobre las ecuaciones \ref{ec:SPH18} y \ref{ec:SPH19}. Tras realizar este proceso, tal como se describe en Moanghan [cite:@Monaghan92], se consiguen las ecuaciones \ref{ec:SPH20} y \ref{ec:SPH21}.

# %Siguiendo el mismo procedimiento de aproximación utilizado para obtener la ecuación \ref{ec:SPH17} se va aplicar a las %ecuaciones \ref{ec:SPH18} y \ref{ec:SPH19}.  Con ello, estas dos ecuaciones
# %Extrapolando este resultado para el caso de la divergencia se tiene:
\begin{equation}\label{ec:SPH20}
\nabla^l \tilde{f}(r_i) = \frac{1}{\rho_i}
\left[ \sum_{j=1}^{N}m_j\left[f(r_j)-f(r_i)\right]\nabla^l_i W_{ij}
\right]
\end{equation}


\begin{equation}\label{ec:SPH21}
\nabla^l \tilde{f}(r_i) = \rho_i
\left[
 \sum_{j=1}^{N}m_j
 \left[
  \left(\frac{f(r_j)}{\rho_j^2}\right)+
  \left(\frac{f(r_i)}{\rho_j^2}\right) \right]\cdot \nabla^l_i W_{ij}
\right],
\end{equation}

Si bien ambas ecuaciones son simétricas y cumplen las premisas de SPH, Monaghan recomienda implementar \ref{ec:SPH21} ya que garantiza mejores resultados que utilizando la ecuación \ref{ec:SPH20}.


** Descripción del Método SPH                                     :noexport:

El método de partículas suaves (SPH, por sus siglas en inglés) fue propuesto originalmente por los investigadores G.R. Lucy [cite:@Lucy77] en 1977 y J.J. Monaghan [cite:@Monaghan82] en 1985. En estos trabajos iniciales, se presentó el método como una técnica numérica para resolver ecuaciones de fluidos mediante la representación del fluido como un conjunto de partículas, cada una con su posición y velocidad.

En estas publicaciones se propuso el uso de una función de interpolación suave (/función kernel/) para calcular las propiedades del fluido en cualquier punto del espacio a partir de las posiciones y velocidades de las partículas. Con este método, se logró simular una gran variedad de problemas y geometrías complejas y con movimiento libre de la malla.

En los años siguientes, investigadores como M.L. Beckermann y J.C. Rieger (1994) y M. S. Long (1995) han extendido y mejorado el método, añadiendo mejoras como la posibilidad de simular problemas multi-materiales y la inclusión de términos de viscosidad artificial.

Otros autores incluyen a:

G.R. Liu y M.B. Liu: en su libro "Smooth Particle Hydrodynamics: A Meshfree Particle Method" (2003) presentan una revisión detallada de la historia, fundamentos y aplicaciones del método SPH.

J.J. Monaghan: es uno de los principales investigadores en el desarrollo de la versión original del método SPH. En su trabajo "Smooth Particle Hydrodynamics" (1992) presenta una revisión detallada de los fundamentos y las aplicaciones del método SPH.

D.J. Price: es otro investigador importante en el desarrollo del método SPH. En su trabajo "Smooth Particle Hydrodynamics: A Review of Recent Developments" (2012) presenta una revisión actualizada de los fundamentos y las aplicaciones del método SPH.

** Formulación del Método SPH                                     :noexport:

La formulación integral de las ecuaciones del método SPH incluye tres pasos básicos:

- Calculo de la densidad de cada partícula: se utiliza una función de suavizado (como por ejemplo, una función de Kernel Gaussiana) para interpolación entre las partículas y calcular la densidad de cada una de ellas. Esto se hace mediante la siguiente ecuación:

- Calculo de la velocidad de cada partícula: una vez que se conocen las densidades de todas las partículas, se puede calcular la velocidad de cada una de ellas utilizando la ecuación de movimiento y teniendo en cuenta las fuerzas que actúan sobre ellas. Esto se hace mediante la siguiente ecuación:

- Actualización de la posición de cada partícula: una vez que se conocen las velocidades de todas las partículas, se puede actualizar su posición utilizando la siguiente ecuación:

  Es importante tener en cuenta que estas ecuaciones son solo una parte de la formulación completa del método SPH. Además, hay muchas variantes y modificaciones posibles de estas ecuaciones para mejorar la precisión y robustez del método.

* Búsqueda de partículas vecinas

** Introducción

La búsqueda de partículas vecinas es una de las tareas fundamentales en el método de partículas suaves (SPH). Es necesario encontrar las partículas vecinas de una partícula dada para poder calcular las propiedades del fluido en ese punto utilizando funciones de interpolación suaves.

Hay varios métodos para buscar partículas vecinas en SPH. Algunos de los métodos más comunes incluyen:

- Listas de vecindad estáticas: en este método, se construye una lista de vecindad estática para cada partícula al principio de la simulación y se utiliza para todo el tiempo de simulación. Es importante reconstruir la lista de vecindad en caso de que las particulas se salgan de su vecindario original.

- Búsqueda vecinal dinámica: en este método, se buscan las partículas vecinas de una partícula dada en cada paso de tiempo. Se puede utilizar estructuras de datos como el octree o el kd-tree para hacer esta búsqueda de manera eficiente.

- Grids: Es una aproximación de malla de cuadros regular, es decir, se divide el espacio en celdas regulares y se clasifican las partículas en las celdas correspondientes, permitiendo una búsqueda eficiente de las particulas vecina.

En general, el tiempo de cálculo para la búsqueda vecinal es proporcional al número de partículas, y puede ser un cuello de botella importante en simulaciones de gran escala. Por esta razón, es importante seleccionar el método de búsqueda vecinal adecuado para cada simulación y optimizarlo para mejorar el rendimiento.

** Búsqueda de vecinas basadas en etiquetado Hash

La búsqueda de vecinos basada en etiquetado hash es una técnica utilizada para encontrar partículas vecinas en el método de partículas suaves (SPH). Esta técnica se basa en el uso de una tabla hash para almacenar las partículas en diferentes "celdas" en función de su posición en el espacio.

En esta técnica, se divide el espacio de simulación en celdas regulares y se etiquetan las partículas mediante una función hash que asigna a cada partícula una "etiqueta" basada en su posición. Luego, se buscan las partículas vecinas a través de un recorrido de las celdas adyacentes a la celda de la partícula dada.

La ventaja de este método es que, al clasificar las partículas en las celdas, se puede limitar el número de partículas que se deben revisar para encontrar vecinos a solo aquellas en las celdas adyacentes. Esto reduce significativamente el tiempo pde búsqueda y permite una mayor escalabilidad en similaciones de gran escala.

Sin embargo, esta técnica tiene algunas desventajas. Puede haber un sobreabundancia de partículas en ciertas celdas y una falta de partículas en otras, lo que puede causar problemas de precisión en la búsqueda de vecinos. Además, puede ser necesario ajustar el tamaño de las celdas en función de la densidad de las partículas para evitar problemas de precisión.

En general, la búsqueda de vecinos basada en etiquetado hash es una técnica eficiente para encontrar vecinos en SPH, pero requiere una buena comprensión de los detalles y puede requerir ajustes para adaptarse a diferentes situaciones.

** Búsqueda de vecinas basadas Fuerza bruta

La búsqueda de vecinos en el método de partículas suaves (SPH) mediante fuerza bruta consiste en comparar la posición de cada partícula con la posición de todas las demás partículas para encontrar las partículas vecinas. Es una técnica simple, pero tiene un tiempo de ejecución que crece de manera cuadrática con el número de partículas, lo que la hace ineficiente para simular grandes conjuntos de partículas.

En esta técnica se recorren todas las partículas, y se compara su posición con la de cada otra particula para determinar si está dentro del radio de vecindad. Se puede utilizar un radio fijo o un radio variable para determinar la vecindad.

Este método es útil para pequeñas cantidades de partículas, pero se vuelve ineficiente para sistemas grandes debido a su complejidad computacional. En lugar de esto, se recomiendan técnicas de búsqueda vecinal más eficientes, como el uso de estructuras de datos como /octree/, /kd-tree/ o etiquetado /hash/.

* Método de integración temporal

** Introducción

En el método de partículas suaves (SPH), los métodos de integración temporal se utilizan para resolver las ecuaciones de conservación de masa y movimiento numéricamente y actualizar las posiciones y velocidades de las partículas en el tiempo. Algunos métodos comunes de integración temporal en SPH incluyen:

- Método de Euler: es el método más simple de integración temporal. Consiste en calcular las nuevas posiciones y velocidades de las partículas a partir de las velocidades y aceleraciones actuales utilizando las ecuaciones de movimiento. Sin embargo, este método tiene una baja estabilidad temporal y suele ser utilizado solo para problemas simples.

- Método de Euler semimplícito: es una variante del método de Euler que se utiliza para mejorar la estabilidad temporal. Consiste en calcular las nuevas posiciones de las partículas a partir de las velocidades actuales y las aceleraciones interpoladas, mientras que las nuevas velocidades se calculan a partir de las aceleraciones actuales.

- Método de Verlet: es un método de integración temporal que se basa en el uso de la posición actual y la posición anterior para calcular la velocidad y la nueva posición de las partículas. Es un método más estable que el método de Euler y se utiliza comúnmente en SPH.

** Ecuación fundamental para la integración temporal numérica

La idea subyacente en la integración temporal numérica es la de aproximar la solución de un sistema dinámico (como las ecuaciones de movimiento) mediante una serie de pasos discretos en el tiempo.

La idea es dividir el tiempo en pequeños intervalos (llamados pasos de tiempo) y calcular la solución en cada uno de estos intervalos. En cada paso de tiempo, se utilizan las condiciones iniciales (como la posición y velocidad de las partículas) y las ecuaciones de movimiento para calcular la solución en el siguiente paso de tiempo. Esto se repite sucesivamente para todos los pasos de tiempo, generando una serie de soluciones que representan la evolución del sistema en el tiempo.

La precisión de la solución numérica dependerá del tamaño del paso de tiempo elegido y del método de integración temporal utilizado. Los métodos de integración temporal más precisos son los de orden superior, como el método de Runge-Kutta, que utilizan más información para calcular la solución en cada paso de tiempo, pero son también más computacionalmente costosos.

En resumen, la integración temporal numérica busca aproximar la solución de un sistema dinámico dividiendo el tiempo en pequeños intervalos y utilizando las condiciones iniciales y las ecuaciones de movimiento para calcular la solución en cada paso de tiempo. La precisión de la solución depende del tamaño del paso de tiempo y del método de integración temporal utilizado.

(Ecuaciones)

** Comparativa entre métodos implícitos y explícitos

En la integración temporal numérica, los métodos implícitos y explícitos se refieren a cómo se utilizan las soluciones en un paso de tiempo para calcular la solución en el siguiente paso de tiempo.

Los métodos explícitos son aquellos en los que las soluciones en un paso de tiempo son utilizadas directamente para calcular la solución en el siguiente paso de tiempo. Es decir, las soluciones en un paso de tiempo no afectan a las soluciones en el siguiente paso de tiempo. Los métodos explícitos son fáciles de implementar y rápidos, pero su estabilidad temporal esta limitada por el tamaño del paso de tiempo. Ejemplos de métodos explícitos son el método de Euler, Verlet.

Por otro lado, los métodos implícitos son aquellos en los que las soluciones en un paso de tiempo son utilizadas para calcular las soluciones en el siguiente paso de tiempo de manera implícita, a través de la resolución de un sistema de ecuaciones no lineales. Estos métodos son más estables temporalmente, pero requieren más cálculos y son más complejos de implementar. Ejemplo de métodos implícitos son los métodos de Runge-Kutta, Euler-implícito.

En resumen, la diferencia entre los métodos implícitos y explícitos de integración numérica radica en cómo se utilizan las soluciones en un paso de tiempo para calcular la solución en el siguiente paso de tiempo. Los métodos explícitos son fáciles de implementar y rápidos pero con menor estabilidad temporal, mientras que los métodos implícitos son más estables temporalmente pero más complejos de implementar.

* Colisiones
** Introducción

Las colisiones es uno de los principales comportamientos a simular en las simulaciones físicas, saber como reaccionan dos elementos al encontrarse en el mismo espacio y tiempo. Para responder a esta pregunta se necesita saber el material, textura y lo más importante geometría de los objetos para saber si se encuentran en el mismo espacio de tiempo y como responden después de este.

Al tratar en nuestro proyecto con una metodología SPH que trata el conjunto de nuestro fluido como partículas independientes podemos suponer que uno de las geometrías de las que debemos conocer si han colisionado es el de la esfera. Se desarrollará una explicación sobre las diferentes colisiones que puede tener una esfera con otros cuerpos rígidos.

- *Colisión caja*:

  Para saber si una esfera (o partícula en nuestro caso) ha colisionado con un cuerpo geométrico con la forma de un cubo. Sabiendo que un cubo tiene todos sus lados perpendiculares podemos definir este mismo a través de los límites de sus tres dimensiones, o dicho de otra manera las posiciones de sus extremos que llamaremos /límites/. Una vez conocidos los límites inferiores y superiores de nuestro cuerpo geométrico podemos razonar que si la posición de nuestra partícula se encuentra dentro de la figura geométrica y sus coordenadas son menores o superiores a alguno de los límites del cubo esta ha colisionado con alguna de las caras del cubo. Análogamente si suponemos que la partícula se encuentra en el exterior de la caja seguiríamos necesitando los mismos parámetros para definir nuestro cubo pero esta vez la colisión se detectaría si estuviera dentro de esos límites.

  #+CAPTION: Colisión caja
  #+ATTR_LATEX: :width 8cm
  [[./graficos/caja-vacia.pdf]]

  Ya que los dos métodos son análogos para la detección nos centraremos en explicar la partícula dentro del cubo ya que es uno de los usos más comunes para representar un fluido contenido en un espacio cerrado.

  La manera de implementar esto de una manera algorítmica se puede definir con la siguiente fórmula:


- *Colisión cilindro*:

  Igual que con otra colisión con una forma geométrica simple conocida podemos resolver si se ha producido una colisión entre nuestra partícula y el cuerpo rígido conociendo su altura o el límite de su coordenada Y (suponiendo que el cilindro tiene una posición vertical paralela al eje Y de nuestro sistema global) y el radio de éste con respecto a su eje. La partícula estará colisionando si la distancia de la partícula hacia el eje es menor que el radio y si cumple la condición de estar entre los límites de la altura del cilindro. La partícula ha colisionado con el cilindro

  #+CAPTION: Colisión cilindro
  #+ATTR_LATEX: :width 8cm
  [[./graficos/cilindro.pdf]]

  La manera de implementar esto de una manera algorítmica se puede definir con la siguiente formula:

- *Colisión esfera*:

  La colisión esfera partícula es una de las más sencillas de implementar y entender pues solo se necesita conocer el radio y el centro de la esfera con la que se va a colisionar para calcular la distancia entre nuestra partícula y la esfera con la que se quiere detectar la colisión. Al conocer estos parámetros solo necesitaríamos aplicar una operación vectorial que nos dijera el módulo o distancia entre nuestra partícula y el centro y una vez obtenida esa distancia calcular si es menor que el radio de la esfera si el resultado es verdadero nuestra esfera ha colisionado con la particula.

  #+CAPTION: Colisión esfera
  #+ATTR_LATEX: :width 8cm
  [[./graficos/esfera.pdf]]

  La manera de implementar esto de una manera algorítmica se puede definir con la siguiente formula:


- *Colisión triangulo*:

  La colisión de triángulo partícula es una de las más difíciles de implementar y visionar ya que requiere de una gran cantidad de operaciones matemáticas para calcular si la particula ha colisionado o no con un triángulo. Esto conlleva un alto coste computacional que “perderíamos” si la partícula no llegara a colisionar pero de todas maneras es necesario explicarlo junto con su implementación ya que la mayoría de modelos existentes no son figuras geométricas con alta simetría que nos permiten calcular rápidamente sus colisiones si no que son mallas de triángulos que forman todo tipo de figuras, además el estándar en la industria es que los modelados sean mallas de triángulos ya que con esto se puede representar cualquier figura o modelo, desde una caja 8 triángulos hasta al famoso conejo /Stanford bunny/ compuesto por 69.451 triángulos.


  #+CAPTION: Colisión triángulo
  #+ATTR_LATEX: :width 8cm
  [[./graficos/triangulo.pdf]]

  Imagen cubo triangulo
  Imagen Stanford bunny triángulos

  Los parámetros necesarios para conocer si existe la colisión entre una partícula y un triángulo en un espacio 3D es conocer los vértices del triangulo junto con la posición de la particula.

  Para este proceso denominado campo de distancia nos permite determinar si existe colisión entre la particula y el triangulo independientemente de la orientación y posición en la que se encuentre el triangulo. Para ello nuestro primer paso es determinar si la particula esta a una distancia en la que es posible que colisionara con el triangulo

** Etapa de detección de la colisión fluido-contorno
*** Técnicas de detección basada en límites
*** Técnicas de detección basada en campo de distancias
** Etapa de la respuesta dinámica a la interacción fluido-contorno
** Estructura del proceso de colisión
* Características de las herramientas de implementación del proyecto
** Introducción
** Características del lenguaje C

Como ya hemos visto nuestro proyecto de simulación de fluidos se ha construido sobre dos librerías para unos resultados iniciales que luego se exportaran a un motor de renderizado.

Debido a que el objetivo de este proyecto se ha enfocado en reducir lo máximo posible el tiempo de calculo necesario para el muestreo de los resultados. Se ha utilizado el lenguaje C debido a las siguientes razones. Tanto CUDA como OpenGL tienen soporte en C cuya incorporación en este mismo lenguaje esta documentado, mantenido y siendo usado por varios desarrolladores.

C también es por si solo uno de los lenguajes multiplataforma que permite una gran eficiencia del código y es el mas utilizado actualmente en el desarrollo de software. Debido a que permite estructuras típicas de los lenguajes de alto nivel pero también nos da acceso a funciones de control de bajo nivel como puede ser el manejo de la memoria. Características que nos resultan muy útiles a la hora de desarrollar nuestro proyecto.

** Características del lenguaje CUDA

CUDA (Compute Unified Device Architecture) es una plataforma de cálculo paralelo y un modelo de programación desarrollados por la empresa NVIDIA Corporation para el cálculo general en unidades de procesamiento gráfico (GPU). Con CUDA, los desarrolladores pueden acelerar drásticamente las aplicaciones de cálculo aprovechando la potencia de las GPU.

Algunas de las características más relevantes del lenguaje CUDA son:

- Paralelismo: CUDA permite ejecutar cálculos en paralelo en una GPU, lo que permite acelerar los cálculos y mejorar el rendimiento de las aplicaciones.

- Programación de alto nivel: CUDA es un lenguaje de programación de alto nivel, lo que significa que se parece y se usa como un lenguaje de programación general como C/C++, Java, Python.

- Compatibilidad con lenguajes de programación comunes: CUDA se integra bien con lenguajes de programación comunes como C/C++ y Fortran, lo que permite a los desarrolladores utilizar las funciones de programación de alto nivel de CUDA junto con los lenguajes de programación existentes.

- Modelo de programación paralelo: CUDA proporciona un modelo de programación paralelo basado en tareas de punto flotante de alta precisión, que permite a los desarrolladores dividir una tarea en subprocesos que se ejecutan en paralelo en una GPU.

- Memoria compartida: CUDA permite el acceso a la memoria compartida entre las diferentes unidades de procesamiento en una GPU, lo que permite una mayor flexibilidad en la programación paralela.

- Entorno de desarrollo: NVIDIA proporciona un entorno de desarrollo integrado (IDE) y herramientas de depuración para CUDA, lo que facilita el desarrollo y la depuración de aplicaciones CUDA.

En general, CUDA es un lenguaje de programación eficiente para el desarrollo de aplicaciones paralelas en GPU. Pero es importante notar que solo es compatible con tarjetas gráficas de NVIDIA y que es necesario tener un conocimiento específico de paralelismo y GPU's para sacarle provecho.

#+CAPTION: Sistema de computación en sistemas heterogénos CPU + GPU
#+ATTR_LATEX: :width 8cm
[[./graficos/CPU+GPU.pdf]]

Pero para entender verdaderamente como funciona CUDA primero hay entender como funciona la programación tradicional o secuencial y como trabaja CUDA con programación en paralelo. La programación secuencial, la que se utiliza mayoritariamente para en toda la computación clásica, es aquella en la que solo se ejecuta una instrucción a la vez y hay que esperar que el ordenador termine para ejecutar la siguiente. Es el modelo de programación clásica y debido a que los sistemas informáticos son extremadamente rápidos en estos momentos no es perceptible. Pero para aplicaciones en las que el tiempo de ejecución es vital y existe un alto coste computacional no se puede permitir ese desperdicio de recursos ya que técnicamente en la programación secuencial al esperar que se acaba cada instrucción se están desperdiciando recursos del sistema en vez de utilizarlos para otra tarea. Es por eso que surge la programación en paralelo en la que varias instrucciones se ejecutan a la vez utilizando la mayor cantidad de recursos disponibles del sistema.

Por otra parte, el desarrollo del hardware ha hecho que los procesadores de las tarjetas gráficas, el componente hardware encargado del procesamiento de datos relacionados con imágenes y videos, sean extremadamente potentes en la actualidad, optimamente capacitadas para este tipo de cálculos intensivos. Su rendiemiento es muy superior al que se obtiene con los otros procesadores, utilizados para ejecutar la mayoría de programas. Es en este contexto, donde CUDA realiza un trabajo excelente, al permitir programar paralelamente en estas tarjetas gráficas de una manera sencilla.

Cuda permite utilizar el procesador del sistema y utilizar los múltiples núcleos de programación de las tarjetas gráficas, además de permitir creación de funciones que se ejecutaran paralelamente en los núcleos de GPU.

La tecnología CUDA se basa en dos pilares el /host/ (el procesador principal) y el /device/ (la tarjeta grafica). El código secuencial se ejecutara en el /host/ y el código que alto coste computacional se ejecutara en el /device/.

#+CAPTION: Modelo de programación heterogéna
#+ATTR_LATEX: :width 10cm
[[./graficos/prog-heterogenea.pdf]]

#+CAPTION: Jerarquía de memoria dentro de la arquitectura CUDA
#+ATTR_LATEX: :width 10cm
[[./graficos/jerarquia-memoria.pdf]]

** Características de OpenGL

Una librería gráfica es conjunto de programas que implementan versiones optimizadas de funciones y métodos que facilitan al programador la renderización de gráficos para mostrarlos en un dispositivo electrónico de salida de video, ya sean monitores de computadora o cascos RV. Incluyen rutinas de gestión de texturas, de generación de efectos de iluminación y sombreado, y que pueden aprovechar hardware de las actuales tarjetas gráficas

Existen diferentes librerías gráficas de bajo nivel, es decir, aquellas que permiten sacar el máximo partido al hardware, aunque también son más complejas de programar. De entre estas se pueden destacar debido a su amplio uso en el sector de la computación gráfica, Vulkan, DirectX y OpenGL. Todas ellas tienen sus ventajas e inconvenientes y destacan en ciertos aspectos sobre otros. En este proyecto para una ilustración previa de los resultados se ha utilizado OpenGL.

Debido a que OpenGL no es solo una API o librería si no una especificación de como ciertas funciones tienen que devolver cierto tipos de resultados, se han desarrollado varias librerías implementadas normalmente por los creadores de las tarjetas graficas (/OpenGL Utility Toolkit/ - GLUT, /Simple DirectMedia Layer/ - SDL, /Simple and Fast Multimedia Library/ - SMFL o /Graphics Library Framework/ - GLFW), que deben ser implementadas conforme a las especificaciones de OpenGL. Esto ha llevado a que la implementación de OpenGL pueda tener comportamientos extraños debido a incompatibilidades con algunas tarjetas graficas o la falta de mantenimiento de ciertas librerías por parte de sus desarrolladores.

GLFW (/Graphics Library Framework/) es una pequeña librería en C que permite la creación y gestión de ventanas con contextos OpenGL, haciendo posible también el uso de múltiples monitores y modos de vídeo. Proporciona acceso a la entrada del teclado, ratón y joysticks. La API proporciona una fina capa de abstracción multiplataforma, principalmente para aplicaciones cuya única salida gráfica es a través de la API OpenGL. Aunque GLFW es muy útil cuando se desarrollan aplicaciones OpenGL multiplataforma, los desarrolladores de una sola plataforma también pueden beneficiarse de su uso al evitar tener que lidiar con diferentes API específicas de la plataforma.

En este proyecto se utiliza la librería GLFW debido a la disponibilidad de gran cantidad y calidad de recursos didácticos que utilizan esta librería como ejemplo para desarrollar sus implementaciones de los conceptos de OpenGL, que se ha tenido que investigar desde cero para la realización de un muestreo de resultados inicial.

* Estrucutra del simulador y resultados
** Introducción
** Estructura del simulador
** Bucle de simulación
** Resultados obtenidos
*** Comparativa en tiempo de renderizado
* Conclusiones y trabajo futuro
* Referencias                                                        :ignore:
#+print_bibliography:
