#+OPTIONS: author:nil
#+OPTIONS: title:nil
#+OPTIONS: date:nil
#+OPTIONS: toc:nil
# #+OPTIONS: num:nil
#+LANGUAGE: es
#+OPTIONS: ':t
#+OPTIONS: H:5
# #+EXPORT_FILE_NAME: ../tex/borrador
#+LATEX_CLASS: etea-empty
#+bibliography: references.bib
#+CITE_EXPORT: biblatex numeric
#+LaTeX_HEADER: \input{~/Sync/proyectos/tfg/tex/tfg-conf.tex}


* Portada                                                            :ignore:

#+BEGIN_SRC latex
    \begin{titlepage}
      \begin{sffamily}
        % \color{azulon}
        \begin{center}
          \begin{figure}
            \makebox[\textwidth][c]{\includegraphics[width=8cm]{logo-uloyola.png}}
          \end{figure}
          \vspace{2.5cm}
          {\Large Grado en Ingeniería Informática y Tecnologías Virtuales}\\
          \vspace{2cm}
          {\Large Trabajo Fin de Grado}
          \rule{10.5cm}{0.1mm}\\
          \bigskip
          {\Huge Simulación de fluidos}\\[10pt]
          {\Huge basada en física}\\[10pt]
          {\Huge utilizando la arquitectura CUDA}
          \vspace*{0.5cm}
          \rule{10.5cm}{0.1mm}\\
          \vspace*{0.9cm}
          {\large Autor}\\
          {\Large Antonio Moreno Talero}\\
          \vspace*{1cm}
          {\large Tutor}\\
          {\Large Juan J. Perea Rodríguez}
          \vfill
          {\large Sevilla, febrero 2023}
        \end{center}
        \color{black}
      \end{sffamily}
  \end{titlepage}

  \newpage
  \thispagestyle{empty}
  \mbox{}
  \newpage
#+END_SRC


* Contenido                                                          :ignore:

#+BEGIN_SRC latex
  \frontmatter
  \tableofcontents
  \listoffigures
  \listoftables
  \mainmatter
#+END_SRC


* Introducción

La computación gráfica o gráficos por ordenador también conocida por sus siglas en ingles CG (/Computer Graphics/) es el campo de la informática que trata de la generación y procesamiento de imágenes y gráficos mediante el uso de algoritmos y técnicas de programación. En la actualidad, es una tecnología clave para multitud de sectores, que van desde el cine, la fotografía digital, los videojuegos hasta la investigación científica, la arquitectura, la medicina o el diseño de vehículos.

El proyecto desarrollado para este Trabajo de Fin de Grado se centra en el uso de la metodología de generación de imágenes mediante un proceso de simulación. En concreto, se plantea una simulación basada en física, también designada como simulación dinámica.

La simulación de un sistema dinámico implica resolver las complejas ecuaciones en derivadas parciales con las que se describe, cuantitativamente, su comportamiento. Para llevar a cabo esta tarea, es necesario utilizar métodos numéricos que transforman esas complejas ecuaciones diferenciales en un conjunto de ecuaciones algebraicas, relativamente más sencillas de manejar e implementables en sistemas computacionales.

De forma aún más específica este proyecto se centrará en la simulación del comportamiento de los fluidos. La simulación de fluidos es una técnica utilizada en la ingeniería y en la ciencia para modelar y predecir el comportamiento de la dinámica de medios continuos, como es el caso del flujo de un fluido, en un sistema determinado. Se utiliza en una gran variedad de aplicaciones, como la simulación de procesos industriales, el diseño de aeronaves, vehículos e incluso en la predicción meteorológica.

Para que estas técnicas puedan ser utilizadas es necesario modelar la continuidad del fluido en un conjunto discreto de /entidades/ conexas.

Entre los diferentes métodos numéricos que se han desarrollado, merecen destacar, por su extenso uso: el Método de Elementos Finitos o FEM (del inglés /Finite Element Method/), el Método de los Volúmenes Discretos o DVM (del inglés /Discrete Volume Method/) o /Particles in cell/ (PIC), en la que las /entidades/ conexas son polígonos conexos que forman una malla. Por otro lado, existen técnicas que no se basan en la discretización mediante mallas. Entre este tipo de metodologías destaca el Método /Smoothed Particles Hydrodynamics/ (SPH) en el que las entidades son partículas libres que se /conectan/ directamente a través de funciones continuas decrecientes. Este último método es el que vamos a utilizar en nuestro proyecto.

Si bien se realizará una descripción más específica en el Capítulo [[*Fundamentos del Método SPH]], seguidamente se describen  algunas de las características más generales del método SPH.

La dinámica de un fluido se refiere al comportamiento del fluido y a su evolución en el espacio y el tiempo. Esto también implica dar respuesta a cómo el fluido se mueve, cómo cambia de forma o cómo cambian sus propiedades físicas.

Una de las principales ecuaciones que rigen la dinámica de los fluidos es la ecuación de Navier-Stokes, que describe cómo la velocidad, la presión y la densidad del fluido cambian con el tiempo y el espacio. Esta ecuación se basa, exclusivamente, en la conservación del momento, y tiene en cuenta factores como la viscosidad, las fuerzas externas y la inercia del fluido.

Igualmente, la dinámica de un fluido también se ve afectada por la /estratificación/. Esta se presenta cuando las diferentes capas de un fluido tienen distintas velocidades debido a diferencias en las propiedades del fluido, como la densidad o la viscosidad. Esto puede dar lugar a distintos fenómenos como los remolinos o las corrientes turbulentas.

Otro factor importante en la dinámica de los fluidos es la turbulencia, que es el movimiento caótico e irregular de un fluido. La turbulencia puede estar causada por factores como las diferencias de velocidad, las irregularidades en la superficie o las perturbaciones externas. El factor de la turbulencia puede tener un gran impacto en la dinámica de un fluido, ya que puede aumentar la mezcla y el intercambio de calor y masa.

En resumen, la dinámica de un fluido se refiere al comportamiento y evolución del fluido en el espacio y el tiempo, y está determinada por una serie de factores como las ecuaciones de conservación de masa y movimiento, la viscosidad, las fuerzas externas, la estratificación y la turbulencia.

Para describir completamente la dinámica del fluido se requiere de hasta nueve ecuaciones en derivadas parciales. No obstante, distintos autores, como Müller [cite:@muller2003particle] Liu [cite:@Liu-Liu03] o Perea et al. [cite:@PerCor12] sugieren la pertinencia de prescindir de un gran número de ellas, y centrarse en la ecuación obtenida a partir de la conservación del momento. Es por ello, que se utiliza la denominada ecuación de Navier--Stokes ([[ec:Navier--Stokes]]) que en su formulación lagrangiana se puede expresar como sigue:
#
#+NAME: ec:Navier--Stokes
\begin{gather}
\rho\frac{\mathrm {D} v}{\mathrm {D} t} = -\nabla P + \nu\nabla^2 v + \rho g
\end{gather}
#
@@latex:\noindent@@ donde
$\rho$ es la densidad del fluido, $\frac{\mathrm {D}}{\mathrm {D} t}$ es la derivada sustancial, $v$ es la velocidad del flujo del fluido, $P$ es la presión del fluido, $g$ es la gravedad y $\nu$ es la viscosidad del fluido.

Esta ecuación expresa el comportamiento del fluido y su dinámica, describiendo cómo la velocidad, la presión y la densidad evolucionan en el tiempo y en el espacio.

Aunque es indudable las ventajas que representa poder operar exclusivamente con la ecuación de Navier--Stokes en la simulación de fluidos, algunos autores han apuntado que precisamente en la simulación de fluidos, es conveniente incorporar la propiedad de /incompresibilidad/, sobre todo en el ámbito de la CG, ya que esta no está considerada en la ecuación de Navier--Stokes. Ha habido distintas propuestas técnicas como las de Solenthaler [cite:@Solenthaler-Pajarola09] y Teschner [cite:@BecTes07] que pretenden resolver el problema /imponiendo/ la incompresibilidad mediante procesos de adaptación de resultados calculando el valor instantáneo de la presión o a través de la composición de la ecuación de Navier--Stokes y la conservación de la masa. Debido a estas desventajas, en este proyecto consideraremos un modelo basado en la propuesta de Perea et al. [cite:@Perea-Cordero16] que impone implícitamente la incompresibilidad.

** Diferentes métodos numéricos

Simular un fluido implica resolver las complejas ecuaciones en derivadas parciales con las que se describe, cuantitativamente, el flujo del fluido. Para llevar a cabo esta tarea, es necesario utilizar métodos numéricos que transformen esas complejas ecuaciones diferenciales en un conjunto de ecuaciones algebraicas, relativamente más sencillas de manejar.

Existen varios métodos numéricos que se han desarrollado para la simulación de fluidos, y se pueden clasificar según su tipología en dos grupos principales:

- *Métodos Eulerianos*

  Se trata de métodos en los que se considera el fluido como un medio continuo (mallas, generalmente de triángulos o cuadriláteros, en el caso de bi–dimensional o bien, hexaedros o tetraedros, para el caso tridimensional) y se describen las variables en un punto fijo del espacio y el tiempo. Entre estos métodos se encuentran el método de volúmenes finitos o FEM (del inglés /Finite Element Method/) y el método de diferencias finitas o FDM (del inglés /Finite Difference Method/). Ambos métodos se basan en la discretización del espacio y del tiempo y se utilizan para resolver ecuaciones diferenciales. Son ampliamente utilizados para simular el comportamiento de fluidos incompresibles y compresibles, especialmente en casos donde hay un gran número de obstáculos o geometrías complejas. Sin embargo, presentan importantes desventajas ya que las ecuaciones que se obtiene están fuertemente ligadas, no se obtienen unos resultados precisos para simulaciones tridimensionales y requiere un gran coste computacional y de requisitos computacionales. Por eso en el ámbito de CG, no suele utilizarse este tipo de metodologías.

- *Métodos Lagrangianos*:

  Son aquellos métodos en los que se considera el fluido como un conjunto de partículas y se describen las variables en función de la posición y la velocidad de cada partícula. El método de partículas (SPH) es un ejemplo de estos métodos, se basa en la resolución de la ecuación de continuidad y la ecuación de movimiento para cada partícula, utilizando una función kernel para la interpolación entre las partículas. Este método es ampliamente utilizado en aplicaciones como la simulación de fluidos en medios porosos, fluidos multi-componentes y en problemas de dinámica de fluidos complejos.

  Los métodos lagrangianos presentan indudables ventajas frente a los eulerianos, ya que, por una parte, al operar con partículas en lugar de mallas permite una mayor simplificación de los cálculos y permite una gran adaptabilidad al contenedor del fluido, especialmente cuando se simulan líquidos. Por otro lado, resolver la ecuación de Navier--Stoke mediante el uso de técnicas lagrangianas, “genera” un conjunto de ecuaciones desacopladas que facilita el proceso de solución. Otra importante característica de los métodos lagrangianos  es que facilitan simular la interfase entre fluidos –por ejemplo, aire–líquido– y la conservación de la masa.

El SPH (/Smoothed Particle Hydrodynamics/) se presenta como el método más destacable de los métodos lagrangianos. Se trata de un método numérico utilizado para simular el comportamiento de fluidos. En este método, el fluido se representa como un conjunto de partículas que se mueven e interactúan entre sí a través de fuerzas de interacción, definido a partir de las ecuaciones en derivadas parciales con las que se describe el flujo del fluido. Cada partícula tiene una masa y está sujeta a la influencia de las demás partículas, las más próximas, a su alrededor. Esta interacción local es la que modela la interacción y permite reproducir el comportamiento de los fluidos de manera realista. Dado los buenos resultados que ofrece, el método SPH se utiliza a menudo en aplicaciones de simulación de fluidos en la industria del cine y en la ingeniería, así como en la investigación científica.

Algunas de las ventajas específicas asociadas al uso del método SPH son las siguientes:

- Simplicidad de implementación: SPH es relativamente fácil de implementar y requiere poca información previa sobre el sistema que se está simulando.

- Flexibilidad: SPH es un método muy flexible que se puede utilizar en una amplia variedad de aplicaciones y escenarios.

- Capacidad de manejar flujos no newtonianos: SPH es capaz de manejar flujos no newtonianos, lo que lo hace adecuado para la simulación de fluidos con comportamientos no lineales.

- Robustez: SPH es un método robusto que puede manejar cambios bruscos en el flujo y en la topología del sistema.

- Facilidad de paralelización: SPH es fácil de paralelizar lo que permite acelerar la simulación en máquinas con varios núcleos o en /clusters/ de computación.

A pesar de estas ventajas, el método SPH tiene algunos problemas asociados que hace que aún sea un campo de investigación en desarrollo. Algunas de las desventajas que este método presenta son:

- Dificultad para manejar obstáculos sólidos: uno de los principales problemas de SPH es la dificultad para manejar obstáculos sólidos de manera efectiva. Esto puede dar lugar a penetraciones de partículas a través de los obstáculos lo que afecta al realismo de la simulación.

- Pérdida de precisión en la modelización de ondas: SPH tiende a tener dificultades para reproducir ondas de alta frecuencia y amplitud, lo que puede afectar la precisión de la simulación en algunos casos. El resultado es la aparición de atenuación de este tipo de ondas lo que induce sobre-amortiguamiento poco realista.

- Sensibilidad a los parámetros de entrada: el rendimiento de SPH puede ser sensible a los parámetros de entrada, lo que puede hacer difícil encontrar los valores óptimos para una simulación determinada.

** Objetivos

El principal objetivo de este trabajo es desarrollar un simulador tridimensional que sea capaz de simular el comportamiento de un fluido de manera realista y conseguir alcanzar el máximo rendimiento posible utilizando el lenguaje de programación CUDA que permite programar en las GPUs de NVIDIA de manera relativamente sencilla y paralelizar los cálculos de SPH, tales como la búsqueda de partículas vecinas y la actualización de sus posiciones y velocidades, consiguiendo una mayor velocidad en la obtención de estos resultados.

En el desarrollo del proyecto también se ha investigado en solventar los principales inconvenientes que tiene el método SPH, en analizar los diferentes parámetros dentro de la simulación para que la simulación sea estable y estudiar otras propuestas, en desarrollar una implementación que nos permita colisionar de manera realista con diferentes tipos de sólidos rígidos y en implementar exportadores para motores de renderizado para que el proyecto tenga un renderizado de mayor calidad

El proyecto deberá tener una estructura que sea escalable, ya que no se pretende que este proyecto, dado lo ambicioso de sus objetivos, finalice dentro del tiempo disponible durante el TFG, si no que se desarrolle más allá del ámbito de la universidad.

** Organización del proyecto

El presente documento se divide en ocho capítulos, en los cuales se explica el contenido de la investigación, la experimentación realizada, así como los resultados obtenidos durante su desarrollo:

En el capítulo [[*Análisis]] se describirá de manera técnica el proyecto a desarrollar y se enumerarán los requisitos que debe cumplir el trabajo y las herramientas utilizadas en el proceso de desarrollo.

En el capítulo [[*Fundamentos del Método SPH]] se revisará en profundidad el método SPH, especialmente en sus fundamentos matemáticos, los diferentes estudios que avalan el método y los problemas del mismo junto con las diferentes soluciones creadas para solventarlos.

En el capítulo [[*Búsqueda de partículas vecinas]] se expondrán dos de los posibles métodos disponibles para determinar la búsqueda de partículas vecinas dentro de un fluido.

En el capítulo [[*Método de integración temporal]] se explican los diferentes métodos de integración temporal, uno de los pilares en la simulación, qué papel juega dentro de nuestra simulación y se explica la decisión de escoger un método sobre otro.

En el capítulo [[*Colisiones]] se discute brevemente una de las dificultades del método SPH: la reacción ante obstáculos, y como se ha resuelto la problemática desarrollando un gestor de colisiones.

En el capítulo [[*Características de las herramientas de implementación del proyecto]] se detallan las características del lenguaje CUDA, indicando los motivos de su elección y las ventajas e inconvenientes que presenta. También se explica brevemente la librería gráfica OpenGL. Esta librería se utilizó en un principio para visualizar el comportamiento de la simulación de manera gráfica, aunque posteriormente se ha cambiado por un /exportador,/ que directamente exporta los datos de las partículas para un renderizado en un programa comercial.

En el capítulo [[*Estructura del simulador y resultados]] se lleva a cabo la descripción de cómo se ha implantado todo lo explicado anteriormente y la estructura del simulador. Además, se presentan los resultados obtenidos.

Finalmente, en el capítulo [[*Conclusiones y trabajo futuro]] se muestran las conclusiones obtenidas a partir de los resultados y se exponen las diferentes ampliaciones y posibilidades que tiene este proyecto en el futuro.

* Análisis

En este segundo capítulo explicaremos todo lo concerniente al estudio previo desarrollado para el simulador solicitado. Se describirá de manera técnica, se enumerarán los requisitos que se deben cumplir en la aplicación, los objetivos durante la duración del proyecto y las herramientas necesarias.

** Definición del problema real

Se solicita el desarrollo de un simulador que dé como resultado simulaciones de fluidos, con un comportamiento realista y que sea versátil, entendiendo un comportamiento realista como aquel que bajo las mismas condiciones que un evento real se comporta de manera similar al mismo. Con versátil que se pueden modificar las variables del entorno sin que afecte a la precisión de la simulación. Además de intentar aumentar el rendimiento de este.

** Problema Técnico – Product Design Specification (PDS)

Aunque este proyecto de TFG sigue el desarrollo de un simulador y no es una aplicación software al uso, se va a utilizar la metodología PDS para explicar de una manera técnica, desde la perspectiva de un desarrollador, la estructura que sigue el simulador a desarrollar.

** Funcionamiento

El funcionamiento del simulador será tal que, a partir de unos parámetros de entrada a modificar en el código, éste será capaz de ejecutar un número de instrucciones determinadas que darán como resultado un programa que, tras su compilación y ejecución, exportará un número determinado de archivos binarios, que sirven para describir el comportamiento de la simulación. Éstos, más tarde, podrán ser utilizados en un motor de renderizado que nos facilite la visualización de la simulación.

** Entorno

- *Entorno Software*: Para el desarrollo del simulador es necesario un compilador de C/C++ y el software de CUDA (SDK y Toolkit) obtenido a través de la página web de NVIDIA y un entorno de desarrollo integrado o IDE. Debido a que el IDE (Integrated Development Environment) desarrollado por Microsoft, Microsoft Visual Studio 2019, trae integraciones para estas dos piezas de software además de que el SDK de CUDA proporciona proyectos ya configurados en Microsoft Visual Studio, se ha decidido desarrollar el simulador en este IDE y no en otro.

- *Entorno Hardware*: Debido a que el simulador utiliza la librería CUDA que solo funciona con tarjetas desarrolladas por NVIDIA, para la ejecución y desarrollo de nuestro simulador es necesario una tarjeta NVDIA, además debido a que muchas tarjetas de NVIDIA muestran algunos problemas de incompatibilidad en entornos Linux y que hemos decidido utilizar el IDE Microsoft Visual Studio 2019, es necesario contar con un equipo (portátil u ordenador de sobremesa) que opere bajo un sistema operativo Windows.

- *Entorno de Usuario*: El desarrollo de este simulador está orientado a profesionales científicos e investigadores del campo de las Computer Graphics, para resaltar las posibles mejoras que el uso de la programación paralela en GPUs puede acelerar programas altamente costosos como puede ser una simulación de fluidos basada en física. Aun así, los resultados obtenidos del simulador al pertenecer al ámbito de las Computer Graphics y ser altamente visuales pueden ser apreciados por cualquier persona.

** Vida Esperada

Al enmarcarse en un proyecto de investigación es extremadamente complejo especificar la vida esperada del simulador. El desarrollo de este simulador se basa en diferentes estudios ya propuestos como se explica en el capítulo [[*Introducción]], con el objetivo de tener una mejora de rendimiento utilizando la potencia de cálculo que ofrecen el uso y programación de las GPU. Por tanto, se espera que este simulador sirva como punto de partida hacia mejoras en el rendimiento de la simulación de fluidos basada en física y que tenga una duración prolongada, además de que se siga ampliando, una vez acabado el ámbito de este TFG, incorporando los nuevos avances en la investigación y hardware futuros.

También, al ser CUDA una plataforma desarrollada por NVIDA, una de las mayores empresas productoras de tarjetas gráficas en el mundo, ésta ofrece un soporte continuo de sus librerías y, debido al éxito y potencial que ha demostrado su uso por parte de la comunidad científica y profesional, se puede suponer que CUDA no se dejará de mantener en el corto plazo.

** Ciclo de mantenimiento

Al depender el desarrollo de este simulador en gran medida de la evolución del lenguaje CUDA C, éste tendrá que ser revisado frente a posibles mejoras que se implementen en las nuevas versiones desarrolladas por NVIDIA. Además, se deberán tener en cuenta las nuevas publicaciones científicas que puedan resultar en un mejor rendimiento del simulador. Aunque sin esto el simulador seguirá siendo funcional, no estará al día con los nuevos avances y su mejora de rendimiento, por lo que uno de los principales objetivos de este proyecto puede quedar en algo superficial.

** Competencia

Al tratarse del desarrollo de un simulador, podemos considerar como competencia a los diversos estudios presentados cada año en eventos comunitarios que desarrollan grupos de interés en la computación gráfica como SIGGRAPH o Eurographics en los que se presentan los avances realizados cada año en este ámbito por diferentes grupos de investigación y desarrolladores de Software.

** Aspecto Externo

El simulador junto con los resultados obtenidos de este y su aspecto renderizado serán entregados al tutor Juan José Perea Rodríguez, junto con esta memoria que explica la metodología elegida y la estructura del simulador.

** Estandarización

El lenguaje escogido, CUDA C, permite una estandarización, ya que al ser C un lenguaje multiplataforma se podría ejecutar en cualquier sistema operativo, siempre que el equipo  contara con una tarjeta NVIDA. Además, se ha realizado una exportación de resultados a archivos binarios que permiten renderizar la imagen en multitud de herramientas de renderizado, lo que resulta en una portabilidad para la visualización de la simulación aún mayor.

** Calidad y Fiabilidad

Al tratarse el desarrollo de este simulador un TFG el encargado principal del desarrollo de esta herramienta es el alumno Antonio Moreno Talero, siendo supervisado por el tutor académico Juan José Perea Rodríguez para controlar el correcto desarrollo del proyecto. También Juan José Perea Rodríguez al ser un experto en el ámbito de la computación gráfica y la simulación basada en fluidos se encargará de supervisar el proyecto para que cumpla con los fundamentos matemáticos que conlleva una simulación física basada en física.

** Programa de Tareas

El desarrollo del simulador será llevado a cabo en diferentes partes:

1. Primero se realizará un análisis y estudio previo de diferentes metodologías de simulación de fluidos junto con maneras de mejorar el rendimiento de este, con el objetivo de comprender las posibles alternativas existentes en el desarrollo de un simulador de fluidos y que ventajas e inconvenientes presenta cada uno.

2. Una vez elegida la metodología a seguir en el desarrollo de la simulación, se planteará una estructura escalable y funcional que sea programable para su posterior desarrollo a la vez que se estudian las herramientas necesarias para llevar a cabo esta implementación.

3. Por último, tras alcanzar una comprensión suficiente de las herramientas a utilizar se llevará a cabo su implementación en el lenguaje escogido, la programación de la estructura del simulador.

** Pruebas

Al tratarse de una simulación se espera que tenga un comportamiento realista y versátil, y que en ningún momento de la simulación presente comportamientos anómalos, como dispersión de partículas o turbulencias que no tuvieran que relación con el comportamiento a simular. Para ello se ha seguido un desarrollo escalado en el que se ha ido probando y ejecutando diferentes partes del proceso, conforme se iba desarrollando, testeando en vivo cada vez que se añadía una nueva funcionalidad y corrigiendo los errores cometidos.

** Seguridad

El proyecto al ser un simulador no guarda ninguna información privada o importante del usuario por lo que no es necesario implementar ninguna medida de seguridad externa a este.

** Análisis de requisitos

En este apartado se realizará un análisis de requisitos que debe satisfacer el desarrollo del simulador para ser considerado aceptable.

*** Requisitos Generales
A continuación, se definen los objetivos a alto nivel:

- RG-01: El simulador debe producir resultados realistas.
- RG-02: El simulador debe ser versátil.
- RG-03: El simulador debe reducir al máximo el coste computacional.

*** Requisitos de información

A continuación, se presentan los requisitos de información, que presentan la información relevante que es necesaria para un simulador de fluidos:

- RI-01: El usuario debe indicar el número de partículas a utilizar durante la simulación.
- RI-02: Las partículas del simulador deben almacenar sus propiedades constitutivas.

*** Requisitos Funcionales

Los mínimos que debe alcanzar el simulador vienen dados por los siguientes requisitos funcionales:

- RF-01: El simulador debe ser capaz de colisionar con sólidos rígidos.
- RF-02: El simulador debe ejecutar parte del código en paralelo.
- RF-03: Se debe poder añadir diferentes sólidos rígidos dentro del simulador.
- RF-04: Las partículas deben modificar sus posición y velocidad dentro del simulador.
- RF-05: El simulador debe implementar algún algoritmo de búsqueda de vecinas.

*** Requisitos No Funcionales

A continuación, con los requisitos no funcionales se determinan ciertas restricciones que debe cumplir nuestro simulador:

- RNF-01: El simulador debe exportar binarios para su posterior renderizado.
- RNF-02: El simulador debe trabajar sobre una tarjeta NVIDIA.
- RNF-03: El simulador debe trabajar bajo la metodología SPH.

*** Matriz de Trazabilidad de Requisitos

Después de haber especificado todos los requisitos necesarios para la simulación, se debe garantizar que estos van a cumplir los objetivos establecidos. Una herramienta gráfica muy útil para esto es la elaboración de matrices de trazabilidad. Una matriz de trazabilidad es una tabla en la que se relacionan todos los requisitos planteados con los objetivos (requisitos generales) establecidos y sirve para visualizar qué resultado alcanzará cada requisito. Las siguientes tablas muestran las matrices de trazabilidad de los requisitos generales respecto a los requisitos de información, requisitos funcionales y requisitos no funcionales respectivamente.

#+CAPTION[Matriz de trazabilidad de los requisitos generales respecto a los requisitos de información]: Matriz de trazabilidad de los requisitos generales respecto a los requisitos de información \\
#+ATTR_LATEX: :align |c|c|c|c|
|---------+-------+-------+-------|
| RI \ RG | RG-01 | RG-02 | RG-03 |
|---------+-------+-------+-------|
| RI-01   | -     | X     | -     |
| RI-02   | X     | X     | -     |
|---------+-------+-------+-------|


#+CAPTION[Matriz de trazabilidad de los requisitos generales respecto a los requisitos funcionales]: Matriz de trazabilidad de los requisitos generales respecto a los requisitos funcionales \\
#+ATTR_LATEX: :align |c|c|c|c|
|---------+-------+-------+-------|
| RF \ RG | RG-01 | RG-02 | RG-03 |
|---------+-------+-------+-------|
| RF-01   | X     | X     | -     |
| RF-02   | -     | -     | X     |
| RF-03   | X     | X     | -     |
| RF-04   | X     | -     | -     |
| RF-05   | -     | -     | X     |
|---------+-------+-------+-------|


#+CAPTION[Matriz de trazabilidad de los requisitos generales respecto a los requisitos no funcionales]: Matriz de trazabilidad de los requisitos generales respecto a los requisitos no funcionales \\
#+ATTR_LATEX: :align |c|c|c|c|
|----------+-------+-------+-------|
| RNF \ RG | RG-01 | RG-02 | RG-03 |
|----------+-------+-------+-------|
| RNF-01   | X     | -     | -     |
| RNF-02   | -     | -     | X     |
| RNF-03   | X     | X     | X     |
|----------+-------+-------+-------|

* Fundamentos del Método SPH
** Introducción

En la introducción de esta memoria de TFG, describimos las características generales de las magnitudes dinámicas y constitutivas del fluido. También expusimos las complejidades que tiene resolver de la ecuación dinámica del fluido, la ecuación [[ec:Navier--Stokes]], y la imposibilidad de resolverla, en la mayoría de los casos, mediante técnicas analíticas. La consecuencia de esta limitación es la necesidad del uso de técnicas numéricas. Así mismo, esbozamos la metodología lagrangiana que utilizamos en este proyecto para simular el flujo del fluido, concretamente, el método Smoothed Particles Hydrodynamics (SPH).

En este capítulo vamos a concretar las características generales y los fundamentos en los que se basa SPH. Además, describiremos los problemas de estabilidad que pueden presentar los resultados obtenidos mediante SPH. Problemas que hemos considerado para evitarlos y obtener simulaciones realistas en diferentes entornos de simulación.

Si bien el método SPH fue desarrollado por Gingold--Monaghan [cite:@Gingold-Monaghan77] y Lucy [cite:@Lucy77], para la simulación de sistemas de múltiples cuerpos, como ocurre en cosmología, rápidamente fue adaptado para simular las ecuaciones dinámicas asociadas a medios continuos.  Específicamente, la formulación desarrollada por Gingold--Monaghan [cite:@Gingold-Monaghan77], es la que se utilizó para modelar las ecuaciones en derivadas parciales del fluido.

Para poder aplicar el método SPH en la simulación del flujo del fluido, es necesario que el continuo que es el fluido, quede representado, unívocamente, por un sistema de partículas que puedan interactuar entre cada una de ellas. Así pues, para una correcta representación del fluido mediante partículas, se tiene que cumplir que la suma de la masa de todas las partículas sea igual a la masa de la totalidad del fluido. Así queda satisfecha una de las restricciones más importantes en física que es \textit{la conservación de la masa}.  Una vez que el fluido es transformado en un sistema de partículas, se tiene que \textit{modelar} la interacción entre las partículas. Aquí es donde entra en juego la formulación de SPH, que describiremos a lo largo de este capítulo, con las que se modela las ecuaciones en derivadas parciales del fluido. Resumidamente, las dos \textit{piedras angulares} de SPH son:

1. /Las partículas/ donde se particularizan las magnitudes del fluido ($\rho$, $\nu$...), la masa y las magnitudes dinámicas (posición, velocidad, aceleración).

2. /La función para modelar la interacción/, que en el ámbito de SPH, suele denominarse /función kernel/. Esta función debe satisfacer ciertas condiciones, que describiremos posteriormente en este mismo capítulo, entre las que destaca la continuidad, su dependencia de la distancia y que esta dependencia es de monótona decreciente con la distancia, tal como se indica en [cite:@Liu-Liu03].

Visualmente, lo que acabamos de describir se ilustra en la figura [[fig:kernel]].

#+NAME: fig:kernel
#+CAPTION: Ilustración de los pilares en los que se asienta el método SPH: partículas y función kernel. La interacción está restringida por el dominio de la función, cuyo radio es $h$. Las partículas que cumplan que su distancia es inferior a $h$, se denominan partículas vecinas.
#+ATTR_LATEX: :width 10cm
[[./graficos/kernel.pdf]]


Una vez que hemos descrito brevemente los pilares fundamentales del método SPH, seguidamente vamos a llevar a cabo una descripción más precisa. En la sección [[*Fundamentos del Método SPH]] vamos a llevar a cabo la definición de las características generales, enunciadas por Monaghan et al. [cite:@Gingold-Monaghan77] y Lucy [cite:@Lucy77] en sus primeras propuestas, y ampliada a lo largo de las últimas décadas. A continuación, se establecerán las formulaciones matemáticas con las que se modelan las ecuaciones del fluido. Para finalizar el capítulo se establecerán las principales limitaciones que presenta SPH y que son consideradas a la hora de implementar la simulación del fluido planificada en este proyecto.

** Descripción del Método SPH

El método SPH, según se ha explicado en la sección [[*Introducción]], tiene dos pilares fundamentales: las partículas y las funciones kernel. En este método, sobre cada una de las partículas con las que se modela el fluido se definen todas las magnitudes necesarias para resolver la ecuación NS --ecuación [[ec:Navier--Stokes]]--, es decir, la velocidad, la presión, la densidad y la masa. Además, sobre cada una de las partículas se define una función kernel que ``\textit{pondera}'' cada una de esas magnitudes dinámicas, a partir del valor que tienen dichas magnitudes en sus partículas más próximas. Modelar un fluido mediante partículas que no está ligadas a través a una malla implica que el movimiento de las partículas sea el flujo del fluido. Debido a este hecho, se puede afirmar que SPH es un método lagrangiano.

Desde un punto de vista numérico, cuando el fluido es modelado mediante partículas, y sus magnitudes se aproximan mediante SPH, la ecuación de NS se transforma en un conjunto de ecuaciones algebraicas que no están acopladas entre sí. Este desacoplamiento es gracias a la formulación de la función kernel. Según se afirma en Liu et al. [cite:@Liu-Liu03], esta formulación reduce el coste computacional y simplifica los cálculos si se compara con el modelado basado en mallas. No obstante, Price [cite:@Price12] advierte de que el número de partículas vecinas $j$, de cada una de las partículas $i$, debe ser relativamente alto, en un rango mínimo de 80 -- 120. Sin embargo, dependiendo del tipo de función kernel, y más concretamente de su formulación, este rango de valores puede disminuir, tal como se indica en Price [cite:@Price12]  y Perea et al. [cite:@Perea-Cordero16]. Así pues, se puede afirmar que las características analíticas condicionan la calidad de la simulación.

Existe un consenso en relacionar las características analíticas de las diferentes funciones kernel, con la estabilidad y el realismo. A este respecto, se han llevado a cabo una gran cantidad de estudios que establecen cuales deben ser las características esenciales, que una función monótona decreciente, debe satisfacer para obtener simulaciones de fluido realistas. La primera función kernel fue propuesta por Monaghan et al. [cite:@Gingold-Monaghan77; @Monaghan92] y se trata de la función exponencial. Esta función puede proporcionar resultados adecuados, pero presenta una incompatibilidad, que es el hecho de que su radio de dominio soportado $h$ es infinito y dado que este valor establece el número de partículas vecinas, se tendría un alto número, lo cual dificulta el cálculo de las magnitudes dinámicas del fluido, como es destacado en Liu et al. [cite:@Liu-Liu03].

Además de la limitación destacada por Liu et al. [cite:@Liu-Liu03], se han desarrollado diversos estudios que establecen las características que hacen a cualquier función monótona decreciente una ``\textit{buena}'' función kernel. Estos estudios son:

1. Fulk et al. [cite:@Fulk94] establece que el dominio de definición de la función kernel debe ser cerrado y acotado y además su decrecimiento debe ser suave.

2. Otro estudio muy destacado es el llevado a cabo por Cappuzzo et al. [cite:@Capuzzo-DiLisio00] en el que se afirma que la función kernel debe ser una función positiva que induzca también un valor positivo de la densidad de masa.

3. \label{punto:punto2} Dehnen et al. [cite:@Dehnen-Aly12] centra su estudio no sólo en la función kernel, sino también en las características que debe presentar la primera derivada de la función kernel. Según Dehnen  la función kernel debe ser una función par y su gradiente, con el que se obtiene la fuerza de presión en la ecuación [[ec:Navier--Stokes]], debe tener un valor nulo en el origen, es decir, en la posición de la partícula.

4. De las investigaciones desarrolladas por Cabezón [cite:@CabGarRel08], Price [cite:@Price12] y Dehnen et al. [cite:@Dehnen-Aly12], se deduce que la mejor función kernel debería ser continua e infinitamente diferenciable, lo que en matemática analítica se denomina $\mathcal{C}^{\infty}$.

Otras características que tiene el método SPH, que representan una ventaja cualitativa a lo hora de llevar a cabo la simulación son:

1. \emph{La conservación de la masa} que es posible porque la masa de cada partícula $m_{p_{i}}$, representa una fracción de la masa total del fluido, es decir $\sum_i m_{p_{i}} = M_f$, donde $M_f$ representa la masa total del fluido. La principal ventaja es que considerando exclusivamente la ecuación de NS es posible simular el fluido, tal como se desataca en Monaghan y Liu et al. [cite:@Monaghan92; @Liu-Liu03].

2. \emph{Permite definir el límite liquido--aire}, conocida también como superficie libre, en el ámbito de CG [cite:@MulChaGro03] es consecuencia del modelado a través de partículas. Esta característica representa una clara ventaja frente a los modelos basados en mallas, como se destaca en Akinci et al. [cite:@AkiIhmAkin.etal12].

3. \emph{No requiere de la implementación del término de advección.} Por tratarse SPH de una técnica lagrangiana, y el hecho de que las partículas se desplazan con el flujo del fluido, no se debe considerar el término de advección, según se explica en Liu et al. [cite:@Liu-Liu03].

4. \emph{La ecuación de NS se transforma en un conjunto de ecuaciones algebraicas desacopladas.} Comparativamente con los métodos basados en mallas esto representa una ventaja ya que no hay que resolver complejos sistemas de ecuaciones a la hora de implementar la simulación del fluido mediante SPH, como indica Liu et al. [cite:@Liu-Liu03]. Esta ventaja es muy importante si se desea paralelizar el cálculo de la dinámica del fluido.

5. \emph{Simplifica las colisiones del fluido con el contorno}, como describiremos en el capítulo [[*Colisiones]] de esta memoria de proyecto. Se debe a que es más fácil calcular la colisión partícula contorno del cuerpo rígido que la colisión entre diferentes mallas, tal como se indica en Müller et al. [cite:@MulChaGro03].

No obstante, aunque SPH presenta las ventajas que acabamos de describir, puede generar inestabilidades en las simulaciones que afecten a su realismo. Esta limitación se hace muy visible cuando la cantidad de partículas vecinas es baja, entorno a $20$, tal como destaca Yan et al. [cite:@YanPenLiu14]. La complejidad de diseñar una función kernel que evite este problema es una tarea compleja que sale fuera de los objetivos de este proyecto. En este proyecto utilizaremos la propuesta de Perea et al. [cite:@Perea-Cordero16; @Perea-Cordero18] donde se desarrolla un estudio de estabilidad y precisión en simulaciones de fluido mediante SPH y formulan una función kernel que garantiza buenos resultados, aunque el número de partículas vecinas sea bajo.

Tras esta breve introducción al método SPH, el resto del capítulo se organiza como se expone a continuación. En la sección [[*Fundamentos del Método SPH]] vamos a llevar a cabo una descripción de los fundamentos de SPH, tal como las definió Monaghan et al. [cite:@Gingold-Monaghan77] y Lucy [cite:@Lucy77]. Seguidamente, en la sección [[*Fundamentos de SPH y su Formulación]] expondremos cómo quedan las ecuaciones dinámicas del fluido modeladas mediante la formulación SPH. Así mismo, expondremos como se obtienen las ecuaciones discretas, que utilizaremos en nuestro simulador, y como éstas se obtienen a partir de la formulación integral, que es el punto de partida que desarrolló Monaghan et al. [cite:@Gingold-Monaghan77]. El proceso seguido en la descripción es el propuesto por Monaghan [cite:@Monaghan82; @monaghan1992smoothed], Liu [cite:@Liu-Liu03] y Price [cite:@Price12].

** Fundamentos de SPH y su Formulación

Desde la perspectiva de análisis funcional, tal como se describe en Liu et al. [cite:@Liu-Liu03], el método SPH se sitúa dentro de la denominada convolución funcional. Expresándola en otros términos, la convolución permite que cualquier función desconocida pueda calcularse a partir de la combinación de funciones conocidas (que en el ámbito de SPH son las ya mencionadas funciones kernel). A pesar de que este es el fundamento que permite operar con funciones conocidas, para obtener la solución desconocida de las ecuaciones en derivadas parciales que describen la dinámica del fluido, el origen del método SPH, tal como lo establecieron Monaghan [cite:@Gingold-Monaghan77] y Lucy [cite:@Lucy77], difiere en parte. El punto de partida es desarrollar una formulación integral de una función incógnita para, posteriormente, formular su expresión discreta, que será la utilizada en el sistema de partículas que modela el fluido a simular. Según esta ``visión'', Monaghan estableció que la formulación integral de cualquier función incógnita, se puede obtener siguiendo el mismo criterio establecido por Dirac para formular la denominada función $\delta$ de Dirac.

Existe un consenso en descomponer, en dos etapas, las operaciones con las que Monaghan [cite:@Gingold-Monaghan77] establece la ecuación fundamental de SPH acorde con el criterio establecido por Dirac para formular su función $\delta$:

1. \label{punto:paso1Cap2FormIntegral} La primera etapa se basa en considerar, tal como estableció Dirac, la formulación integral de la función  $\delta$, pero considerando que se trata, en lugar de una pulsiana, de una función cerrada y acotada, lo que en el análisis de funciones se conoce como \textit{función compacta}, con un dominio espacial mayor que el de $\delta$. Llegados este punto, merece la pena destacar que esa función compacta, con la que se ``sustituye'' a $\delta$, es la función kernel de SPH, que será descrita con mayor profundidad en la sección [[*Descripción del Método SPH]]. De este modo, Monaghan establece la formulación integral del método SPH.

2. \label{punto:paso2Cap2FormDiscreta} En la segunda etapa se opera sobre la formulación integral desarrollada en la primera etapa, para transformarla en una expresión discreta, esto es, transformar la integral en sumatoria. De este modo, las ecuaciones obtenidas pueden ser aplicadas sobre un sistema discreto como, por ejemplo, es el sistema de partículas con el que se modela el fluido a simular. Por ello, son estas ecuaciones discretas las que utilizaremos en nuestro simulador.

En las próximas subsecciones [[*Formulación integral de las ecuaciones del método SPH]] y [[*Formulación discreta de las ecuaciones del método SPH]] llevaremos a cabo una descripción más exhaustiva de las dos etapas que, brevemente, acabamos de describir. En dichas secciones vamos a seguir las líneas establecidas por Akinci et al. [cite:@AkiIhmAkin.etal12] y Monaghan [cite:@monaghan1992smoothed].

*** Formulación integral de las ecuaciones del método SPH

Esta sección se corresponde con la primera etapa, es decir, con la etapa \ref{punto:paso1Cap2FormIntegral}. Según formuló Monaghan [cite:@Gingold-Monaghan77], a partir de la función $\delta$ de Dirac, cualquier función desconocida  $f$ la expresa en términos de \ref{ec:deltaDirac}:

\begin{equation}\label{ec:deltaDirac}
f(r)=\int f(r')\delta(r-r')dr',
\end{equation}

@@latex:\noindent@@ donde $f$ hace referencia a la función desconocida, $r$ es a la posición, $r'$ es la posición de cualquier punto dentro del dominio de definición de $f$ y $\delta$ es la función de Dirac.

El siguiente paso seguido por Monaghan [cite:@monaghan1992smoothed; @Gingold-Monaghan77] es sustituir la función $\delta$ por una función con extensión espacial. Haciendo ese se obtiene la ecuación fundamental del método SPH. La expresión obtenida es \ref{ec:kernelIntegral}.

\begin{equation}\label{ec:kernelIntegral}
\tilde{f}(r)=\int_{\Omega} f(r')W(r-r',h)dr'
\end{equation}

donde  $(\;\tilde{}\;)$ se utiliza para indicar que $\tilde{f}(r)$ es el valor aproximado de $f(r)$, $W$ es la función con extensión espacial que sustituye a la función $\delta$, la que en SPH se denomina \textit{función kernel}, $\Omega$ es el volumen de definición de $W$ y $h$ es el radio  de dicho dominio de definición, que en el ámbito de SPH se conoce como \textit{radio del dominio soportado}.

Puede deducirse que  la función $W$ de la ecuación \ref{ec:kernelIntegral}, la función kernel, es fundamental en SPH. ``\textit{A priori}'' cabría esperar que cualquier función compacta podría jugar el papel de función kernel, sin embargo, existe un conjunto de características, las cuales serán descritas posteriormente, que la función debe cumplir. Monaghan [cite:@Monaghan92], establece que, al menos, la función kernel debe satisfacer los siguientes criterios:

1. \label{punto:SPH_1} Cualquier función $W$ candidata a ser función kernel, debe estar normalizada y cuando el radio del dominio soportado $h$ tienda a cero, $W$ debe ser una función pulsiana como es la $\delta$ de Dirac, es decir:

   \begin{equation}\label{ec:condNormalizacion}
   \int_\Omega W dr' = 1
   \;\;\;\;\mbox{y}\;\;\;\;\lim_{h\rightarrow 0} W(r-r',h) = \delta(r-r').
   \end{equation}

2. \label{punto:SPH_3} $W$ tiene que ser compacta, es decir, debe ser una función cerrada y acotada. Además, Monaghan sugiere que debe ser una función par, es decir, simétrica respecto del origen y decaer suavemente con la distancia.

Cabe destacar que la elección de la función kernel, es uno de los problemas recurrentes en el ámbito de SPH. Una buena elección, sobre todo cuando el número de partículas vecinas es relativamente bajo, garantiza resultados precisos y, por lo tanto, simulaciones realistas. Existen diferentes estudios en los que se analizan las características que debe cumplir una función compacta y simétrica para ser una buena función kernel. Merece destacar los estudios de Dehnen et al. [cite:@Dehnen-Aly12] y Yan et al. [cite:@YanPenLiu14] donde, además, hace una exposición de cómo controlar el error cometido. Sin embargo, realizar un estudio de las diferentes funciones kernel, queda fuera del ámbito de este capítulo, en el que describimos los fundamentos del método SPH.

*** Formulación integral de las derivadas de las ecuaciones de SPH

Una vez expuesta la formulación integral de SPH, el siguiente paso es ``adaptar'' esa formulación a la ecuación dinámica del fluido, es decir, la ecuación NS [[ec:Navier--Stokes]]. Por lo tanto, es necesario exponer la formulación del gradiente y el laplaciano, en términos de la ecuación \ref{ec:kernelIntegral}, ya que son las funciones que intervienen en la ecuación NS. Siguiendo los términos expuestos en Liu et al. [cite:@Liu-Liu03], se obtiene la ecuación \ref{ec:SPH11}:

\begin{equation}\label{ec:SPH11}
\nabla \cdot \tilde{f}(r)=\int_{\Omega}
\left[
\nabla\cdot f(r')
\right]W(r-r',h)dr',
\end{equation}

donde la expresión $\left[\nabla\cdot f(r')\right]$ se particulariza en $r'$ dentro del dominio soportado de $f$.

Para calcular el integrando de la ecuación \ref{ec:SPH11}, Monaghan [cite:@Monaghan92] hace uso de la regla de la cadena. Con esta operación la ecuación \ref{ec:SPH11} se transforma en la ecuación:

\begin{equation}\label{ec:SPH12}
\left[\nabla \cdot f(r')\right] W(r-r',h)=
\nabla\cdot\left[f(r') W(r-r',h)\right]-
f(r')\cdot \nabla\left[ W(r-r',h)\right],
\end{equation}

Sustituyendo la ecuación \ref{ec:SPH12} en \ref{ec:SPH11}, se obtiene la expresión del gradiente en términos de SPH, la ecuación que se obtiene es la expresión  \ref{ec:SPH13}:

\begin{equation}\label{ec:SPH13}
\nabla\cdot \tilde{f}(r)= \int_{\Omega}
\nabla\cdot\left[f(r')W(r-r',h)\right]dr'-
\int_{\Omega}
f(r')\cdot\nabla\left[W(r-r',h)\right]dr'.
\end{equation}

Tal como se indica en Liu et al. [cite:@Liu-Liu03], la ecuación \ref{ec:SPH13} es válida para calcular el gradiente de cualquier función. Sin embargo, para dotar de significado, se recomienda tener dos componentes, una referida al volumen del dominio soportado y otro, específicamente, asociado al contorno. Expresándolo, en otros términos, en Liu et al. [cite:@Liu-Liu03], se recomienda que haya una componente de volumétrica y otra superficial (la asociada al contorno). Para que ello se cumpla, se hace uso del \emph{Teorema de la Divergencia}, de este modo la ecuación \ref{ec:SPH13} se expresa en términos de la ecuación \ref{ec:SPH14}.

\begin{equation}\label{ec:SPH14}
\nabla\cdot \tilde{f}(r)= \int_{S}
f(r')W(r-r',h)\cdot \vec{n}dS-
\int_{\Omega}
f(r')\cdot\nabla\left[W(r-r',h)\right]dr'.
\end{equation}

donde $\vec{n}$ es el vector normal de la superficie que recubre el dominio $\Omega$.

La descomposición en dos componentes, una superficial y otra volumétrica, de la ecuación \ref{ec:SPH13} para obtener la ecuación \ref{ec:SPH14}, tiene un objetivo claro, tal como se indica en Liu et al. [cite:@Liu-Liu03], y es que si la función es compacta y el dominio soportado no ``penetra'' en los límites del fluido, por ejemplo, en el contenedor en el que se encuentre confinado el fluido a simular, entonces la parte superficial de la ecuación \ref{ec:SPH14} se anula, por lo que se simplifica en términos de:

\begin{equation}\label{ec:SPH15}
\nabla\cdot \tilde{f}(r)=-\int_{\Omega}
f(r')\cdot\nabla\left[W(r-r',h)\right]dr'.
\end{equation}

# %Cabe destacar que si la condición de compacidad no es satisfecha entonces la %ecuación \ref{ec:SPH15} no es adecuada para obtener la aproximación $\nabla\cdot %\tilde{f}(r)$.

Siempre que se cumplan las condiciones para obtener la ecuación \ref{ec:SPH15}, se puede comprobar que el gradiente simplemente se obtiene como el producto de la función kernel por la función incógnita $f$, con lo que se simplifican los cálculos de las ecuaciones en derivadas parciales donde se utilicen, lo cual representa una ventaja operativa respecto de otras técnicas, como destaca Monaghan [cite:@Monaghan92].

En este proyecto vamos a utilizar funciones compactas, con lo que podemos utilizar las ecuaciones que se obtengan a partir de la expresión \ref{ec:SPH15}.


Para obtener ecuaciones diferenciales de orden superior, en Liu et al. [cite:@Liu-Liu03], se propone extrapolar la ecuación \ref{ec:SPH15},para cualquier orden diferencial. Según su propuesta, la ecuación general que permitirá aproximar cualquier ecuación diferencial se expresa en términos de \ref{ec:SPHDerivadasGENERAL}:


\begin{equation}\label{ec:SPHDerivadasGENERAL}
\nabla ^l \tilde{f}(r)=-\int_{\Omega}
f(r')\cdot\nabla^l\left[W(r-r',h)\right]dr'.
\end{equation}

donde con $l$ se hace referencia al orden diferencial, p.e. $l=1$ será el gradiente y $l=2$ será el laplaciano.

*** Formulación discreta de las ecuaciones del método SPH

Mediante las ecuaciones \ref{ec:kernelIntegral}--\ref{ec:SPH15}, se tienen las expresiones con las que es posible transformar, analíticamente, las ecuaciones en derivadas parciales, con las que se describe el fluido, en términos del método SPH. Sin embargo, tal como se ha dicho previamente, estas ecuaciones no se pueden aplicar sobre un sistema discretizado, como es el sistema de partículas con el que se modela el fluido a simular. Para poder aplicar las expresiones \ref{ec:kernelIntegral}--\ref{ec:SPH15} a un sistema discreto, es necesario transformar dichas ecuaciones. Sucintamente, el proceso consiste en transformar las integrales, por sumatorias, restringidas a las partículas. En los estudios de Price [cite:@Price12] y Monaghan [cite:@Monaghan92], se describe el proceso clave que permite dicha trasformación y consiste en considerar que, cada una  de las partículas, representa una fracción del fluido, visto como un continuo, cuyo valor es $\rho\, dV$. Teniendo en cuenta esta hipótesis es posible transformar la expresión \ref{ec:kernelIntegral} en la ecuación \ref{ec:spHAproximada}:

\begin{equation}\label{ec:spHAproximada}
 \tilde{f}(r_i) =\sum_{j\in\mathcal{N}(i)}\frac{m_j}{\rho_{j}}f(x_j) W(r_i-r_j,h),
\end{equation}

donde $\mathcal{N}(i)$ son las partículas vecinas de la partícula $i$, cuya cantidad viene condicionada por el valor del radio de dominio soportado, $h$.

Formulada la ecuación discreta con la que se aproxima la función $f$, el siguiente paso es formular las ecuaciones del gradiente. Siguiendo una línea de razonamiento análogo para obtener \ref{ec:spHAproximada}, Liu [cite:@Liu-Liu03] describe que la ecuación de partida es \ref{ec:gradientePre}.

\begin{equation}\label{ec:gradientePre}
\nabla \cdot \tilde{f}(r)=\int_{\Omega}
\left[
\nabla\cdot f(r')
\right]W(r-r',h)dr'=
\frac{\partial}{\partial r}\int \frac{f(r')}{\rho(r')}W(r-r',h)\rho(r')dr'
\end{equation}

A partir de la ecuación \ref{ec:gradientePre}, considerando que $f$ es compacta y no interseca los límites del fluido, la ecuación \ref{ec:gradientePre} se reduce en términos de la ecuación \ref{ec:gradiente}:

\begin{equation}\label{ec:gradiente}
\nabla \tilde{f}(r)=\frac{\partial}{\partial r}\int \frac{f(r')}{\rho(r')}W(r-r',h)\rho(r')dr'\approx
\sum_{j\in\mathcal{N}(i)}m_j\frac{f_j}{\rho_j}\nabla W(r_j-r_i,h).
\end{equation}

Operando sobre la expresión \ref{ec:gradiente}, con el objetivo de obtener una ecuación similar a la expresión \ref{ec:SPH15}. En Liu [cite:@Liu-Liu03] se concluye que la ecuación discreta con la que es posible calcular la ecuación discreta para calcular el gradiente, que se expresa en términos de :

\begin{equation}\label{ec:SPH17}
\nabla\cdot \tilde{f}(r_i)=-\sum_{j\in\mathcal{N}(i)} \frac{m_j}{\rho_{j}}f(r_j)\cdot \nabla W(r_i-r_j,h),
\end{equation}

donde $\nabla W$ es la función kernel que se particulariza sobre cada una de las  $i$ partículas en las que se ha discretizado el fluido a simular.

Teniendo en cuenta la ecuación \ref{ec:SPH17}, y considerando la condición de compacidad, se puede obtener la ecuación discreta para calcular la derivada parcial para cualquier orden diferencial. La expresión que permite hacer ese cálculo es:

\begin{equation}\label{ec:deDerivadaDiscreta}
\nabla^l\cdot \tilde{f} (r)=-\sum_{j\in\mathcal{N}(i)} \frac{m_j}{\rho_{j}}f(r_j)\cdot \nabla^l W(r-r_j,h),
\end{equation}

Las expresiones obtenidas permiten simplificar el cálculo de las complejas ecuaciones que describen la dinámica del fluido. Sin embargo, estas ecuaciones presentan dos importantes limitaciones:

1. Que la función kernel debe ser compacta y la partícula $i$, sobre las que se particulariza cada función kernel, deben estar lejos del contorno del fluido.

2. Las ecuaciones \ref{ec:deDerivadaDiscreta}, particularizadas para cada $l$, no satisfacen la conservación del momento, tal como advierten Price [cite:@Price12] y Monaghan [cite:@Monaghan92]. Para solventar este problema Monaghan [cite:@Monaghan92] propone el desarrollo de ecuaciones simétricas basadas en la regla de la cadena. El proceso que Monaghan sigue se describirá a continuación.

*** Formulación simétricas de las derivadas de las ecuaciones en SPH

Tal como se ha mencionado en la sección anterior, las ecuaciones discretas del método SPH obtenidas, aunque cumplen los criterios analíticos, no satisfacen la conservación del momento, es decir, no se satisface el principio acción--reacción. Monaghan [cite:@Monaghan92] advierte de este hecho y propone una metodología, basada en la regla de la cadena, para obtener ecuaciones simétricas que satisfagan dicha ley de conservación. Las ecuaciones que permiten simetrizar las derivadas parciales de las funciones desconocidas son \ref{ec:SPH18} y \ref{ec:SPH19}:

\begin{equation}\label{ec:SPH18}
\nabla^l f(r)=\frac{1}{\rho}\left[
\nabla^l \left(\rho f(r)\right)-
f(r)\nabla^l \rho
\right],
\end{equation}

\begin{equation}\label{ec:SPH19}
\nabla^l f(r)=\rho\left[
\nabla^l\left(\frac{f(r)}{\rho}\right)+
\frac{f(r)}{\rho^2}\nabla^l\rho
\right].
\end{equation}

donde $\rho$ hace referencia a la densidad de masa.

# %Las dos identidades anteriores pueden sustituirse por la integral en (11).


Análogamente a como se hizo para calcular la  ecuación \ref{ec:SPH17}, se puede operar sobre las ecuaciones \ref{ec:SPH18} y \ref{ec:SPH19}. Tras realizar este proceso, tal como se describe en Moanghan [cite:@Monaghan92], se consiguen las ecuaciones \ref{ec:SPH20} y \ref{ec:SPH21}.

# %Siguiendo el mismo procedimiento de aproximación utilizado para obtener la ecuación \ref{ec:SPH17} se va aplicar a las %ecuaciones \ref{ec:SPH18} y \ref{ec:SPH19}.  Con ello, estas dos ecuaciones
# %Extrapolando este resultado para el caso de la divergencia se tiene:
\begin{equation}\label{ec:SPH20}
\nabla^l \tilde{f}(r_i) = \frac{1}{\rho_i}
\left[ \sum_{j=1}^{N}m_j\left[f(r_j)-f(r_i)\right]\nabla^l_i W_{ij}
\right]
\end{equation}

\begin{equation}\label{ec:SPH21}
\nabla^l \tilde{f}(r_i) = \rho_i
\left[
 \sum_{j=1}^{N}m_j
 \left[
  \left(\frac{f(r_j)}{\rho_j^2}\right)+
  \left(\frac{f(r_i)}{\rho_j^2}\right) \right]\cdot \nabla^l_i W_{ij}
\right],
\end{equation}

Si bien ambas ecuaciones son simétricas y cumplen las premisas de SPH, Monaghan recomienda implementar \ref{ec:SPH21} ya que garantiza mejores resultados que utilizando la ecuación \ref{ec:SPH20}.

* Búsqueda de partículas vecinas

** Introducción

La búsqueda de partículas vecinas es una de las tareas fundamentales en el método SPH. Tal como se indicó en el Capítulo [[*Fundamentos del Método SPH]], el modo en que se propagan las interacciones en el método SPH, es a través de las partículas que se encuentran dentro del dominio soportado de la función kernel o, dicho de otra manera, de las partículas que se consideren vecinas a otra dada. Determinar cuáles son las partículas vecinas de cada una de las partículas que componen el modelado del fluido, constituye uno de los retos más importantes en la simulación mediante SPH, desde un punto de vista de consumo de tiempo de cómputo. Es decir, resulta necesario encontrar las partículas vecinas de una partícula dada para poder calcular las propiedades del fluido en ese punto utilizando la función kernel.

Existen diversos métodos para buscar partículas vecinas en SPH. Pero podemos dividirlos principalmente en dos tipos.

- Búsqueda exhaustiva:

  /Búsqueda por fuerza bruta/: La búsqueda de vecinas por fuerza bruta es un algoritmo que se utiliza para encontrar las partículas más cercanas a una partícula dada en un conjunto de partículas. El algoritmo consiste en comparar la distancia entre cada partícula y la partícula dada, y luego seleccionar aquellas que estén dentro de un radio definido por la función kernel.

- Discretización del espacio:

  /Grids/: Es una aproximación de malla de cuadros regular, es decir, se divide el espacio en cubos regulares y se clasifican las partículas en los cubículos correspondientes, permitiendo una búsqueda eficiente de las partículas vecina.

** Búsqueda de vecinas mediante Fuerza Bruta

La búsqueda de vecinas en el método kernel de SPH mediante fuerza bruta consiste en comparar la posición de cada partícula con la posición de todas las demás partículas, para encontrar las partículas vecinas. Es una técnica simple, pero tiene un tiempo de ejecución que crece de manera cuadrática con el número de partículas, lo que la hace ineficiente para simular grandes conjuntos de partículas.

En esta técnica se recorren todas las partículas, y se compara su posición con la de cada otra partícula para determinar si la distancia es inferior al radio del dominio soportado, h, de la función kernel. Se puede utilizar un radio fijo o un radio variable para determinar el dominio soportado, tal como se sugiere en Price [cite:@Price12].

El proceso funciona de la siguiente manera:

- Se recorre cada partícula en el conjunto de partículas.
- Para cada partícula, se calcula la distancia entre ella y la partícula dada.
- Si la distancia es menor o igual al radio definido por la función kernel, se considera que es una partícula vecina y se añade a la lista de vecinas.
- Se repite este proceso para cada partícula en el conjunto de partículas.


Este método es útil para pequeñas cantidades de partículas, pero se vuelve ineficiente para sistemas grandes debido a su complejidad computacional, su complejidad es del orden $O(n^2)$. En lugar de esto, se recomiendan técnicas de búsqueda vecinal más eficientes, como el uso de estructuras de datos como /octree/, /kd-tree/ o etiquetado /hash/.

** Búsqueda basada en Grids con marcado Hashing

La búsqueda de vecinas basada en marcado hash se basa en el uso de una tabla hash para almacenar las partículas en diferentes “cubos” en función de su posición en el espacio.

Sucintamente, esta técnica opera sobre divisiones del espacio mediante mallas, cada una de las cuales, y siempre que contengan al menos una partícula, es marcada o etiquetada con un número primo obtenido de una operación lógico-algebraica, la función hash. Luego, se buscan las partículas vecinas a través de un recorrido de los cubículos adyacentes al cubo de la partícula dada.

La ventaja de este método es que, al clasificar las partículas en los cubículos, se puede limitar el número de partículas que se deben revisar para encontrar vecinas a sólo aquellas en los cubículos adyacentes. Esto reduce significativamente el tiempo de cómputo que mejora conforme aumenta el número de partículas a simular y permite realizar simulaciones con un gran número de partículas.

Sin embargo, esta técnica tiene algunas desventajas. El problema es que, si el número de partículas es relativamente bajo, del orden de algunos miles, el procesamiento hash puede ser más costoso que el de búsqueda exhaustiva. Además, no existe una función hash perfecta, por lo que se requiere de un filtrado posterior para evitar la denominada colisión por valor hash, tal como menciona Kelager [cite:@Kelager06].

En general, la búsqueda de vecinas basada en etiquetado hash es una técnica eficiente para encontrar vecinas en SPH, pero requiere una buena comprensión de los detalles y puede requerir ajustes para adaptarse a diferentes situaciones.

El etiquetado hash es una técnica que se utiliza para organizar y acceder rápidamente a datos en una estructura de datos, como un arreglo o una tabla hash. En el contexto de la búsqueda de vecinas en el método SPH, el etiquetado hash se puede utilizar para mejorar el rendimiento del algoritmo de Kelager.

El proceso sería el siguiente:

- Se construye una tabla hash en la que cada entrada representa un cubículo de la cuadrícula y contiene una lista de etiquetas de partículas.

- Para cada partícula, se calcula su posición en la cuadrícula y se asigna una etiqueta única basada en esa posición.

- Se inserta la etiqueta de la partícula en la lista de la entrada de la tabla hash correspondiente al cubículo en la que se encuentra la partícula.

- Al buscar vecinas, se accede a la entrada de la tabla hash correspondiente al cubículo en la que se encuentra la partícula y se buscan las partículas en los cubículos adyacentes a través de las etiquetas.

Uno de los problemas que genera usar etiquetado hash es la coalescencia de memoria, es decir, que las direcciones de memoria que sean cercanas representen cubículos adyacentes en el espacio, de este modo no se pierde un tiempo de cómputo excesivo. Esto lo resolvemos siguiendo la propuesta de Perea et al. [cite:@Perea-Cordero17], realizando la partición del espacio de la siguiente manera:

Primero en el eje X,

#+ATTR_LATEX: :width 8.5cm
[[./graficos/1D.pdf]]


luego en el eje Y

#+ATTR_LATEX: :width 8.8cm
[[./graficos/2D.pdf]]


y por último en el eje Z

#+ATTR_LATEX: :width 9cm
[[./graficos/3D.pdf]]


* Método de integración temporal

La ecuación de NS tiene dependencia espacial y temporal. La componente espacial, esto es, el gradiente, el laplaciano y la densidad la calculamos mediante el método SPH, descrito en el capítulo [[*Fundamentos del Método SPH]]. Sin embargo, la componente temporal, evidenciada mediante la derivada sustantiva, requiere de un tratamiento específico no contemplado en el método SPH. Para tal fin se utilizan otros métodos numéricos tanto explícitos como implícitos, en Modak et al. [cite:@Modak-Sotelino02] se realiza una descripción de las diferentes metodologías. En nuestro proyecto nos vamos a centrar en los métodos explícitos y semi-implícitos algunos de los cuales procederemos a describir a continuación.

** Fundamentos del Método de integración temporal

La idea principal bajo la que operan todos estos métodos numéricos es la de dividir el tiempo en pequeños intervalos, en el que cada uno se separa del anterior por un pequeño incremento de tiempo, ampliamente conocido en el ámbito de las CG como $\Delta t$.

En otras palabras, la idea subyacente en la integración temporal numérica es aproximar la solución de una ecuación diferencial ordinaria (EDO) mediante el uso de valores discretos en intervalos de tiempo específicos, en lugar de tratar de encontrar la solución analítica exacta. Esto se logra mediante el uso de un algoritmo numérico, como un método de integración temporal, que utiliza una serie de pasos para avanzar en el tiempo y calcular los valores de la solución en momentos discretos.

Todos los métodos existentes se pueden dividir en dos categorías: métodos explícitos y métodos implícitos. La principal diferencia entre ellos radica en que mientras que, en los explícitos, se considera que las acciones sobre el sistema, /las fuerzas/, se mantienen constantes a lo largo de todo el paso de tiempo, lo que implica que es posible conocer las aceleraciones en el siguiente paso, ya que son las mismas que en el paso actual. Conocida la aceleración actual, es fácil resolver las ecuaciones de la velocidad y de la posición. Esta hipótesis, la de que las fuerzas se mantienen constante dentro de cada paso de tiempo, no es considerada en los implícitos, por lo que no se conoce ni la aceleración, ni la velocidad, ni la posición en el siguiente paso. Por lo tanto, es necesario poner en función de la aceleración, tanto la velocidad, como la posición y la ecuación obtenida, sustituirla en la ecuación dinámica. Todo ello implica una complejidad que se hace mayor si la aplicamos al sistema de partículas con el que se modela el fluido, ya que, en ese caso, para cada paso de tiempo hay que resolver un sistema de ecuaciones con un número de ecuaciones igual al de partículas.

Computacionalmente, los métodos explícitos son más sencillos de implementar y su resolución es casi directa, ya que con la aceleración se despeja directamente la velocidad y con la velocidad, y/o la aceleración (dependiendo del orden del método de integración), la posición, sin necesidad de procesar un sistema de ecuaciones. No obstante, la principal limitación de los explícitos radica en la hipótesis fundamental en la que se basan: ``las fuerzas se mantienen constante dentro de cada paso de tiempo'', y esto sólo se satisface para pasos de tiempo muy cortos, del orden de fracciones de milésimas de segundo, y en problemas que no sean /stiffness/ (véase  Modak et al. [cite:@Modak-Sotelino02]). Así pues, se puede afirmar, que los métodos explícitos tienen su convergencia a resultados correctos condicionada, mientras que los implícitos se puede decir que no está condicionada, tal como se expone en Modak et al. [cite:@Modak-Sotelino02].

Existe otra posibilidad que aúna características de métodos explícitos e implícitos, son los denominados métodos semi-implícitos. En síntesis, estos métodos consideran la hipótesis de los implícitos, es decir, consideran que las fuerzas se mantienen constantes dentro de cada paso de tiempo, con lo que se conoce la aceleración y con ella se calcula la velocidad en el siguiente paso, y con esta nueva velocidad y aceleración se obtiene la nueva posición. Con este proceso se mejoran los resultados, con pasos de tiempo hasta dos órdenes de magnitud mayores que en los explícitos. Sin embargo, su convergencia sigue estando condicionada. A pesar de ello, los métodos semi-implícitos son muy utilizados en el ámbito de CG y es la tipología que vamos a seleccionar en nuestro proyecto.

Algunos de estos algoritmos numéricos son, por ejemplo:

- /Método de Euler/: Este es uno de los métodos de integración temporal más simples y fáciles de implementar en comparación con otros. Utiliza una aproximación de diferencias finitas para calcular el valor de la solución en el siguiente paso temporal a partir del valor actual. Sin embargo, el método de Euler es poco preciso y puede dar lugar a soluciones inestables si el paso temporal es demasiado grande.

- /Método de Runge-Kutta/: Este es uno de los métodos de integración temporal más populares y utilizados. Utiliza una combinación de aproximaciones de diferencias finitas y diferencias progresivas para calcular el valor de la solución en el siguiente paso temporal. Es más preciso y estable que el método de Euler, pero también es más complejo de implementar.

- /Euler semi-implícito/: Calcula las nuevas velocidades a partir las velocidades actuales y de las nuevas aceleraciones. Para las nuevas posiciones, considera las posiciones actuales, pero utiliza las nuevas velocidades y aceleraciones.

Es este último el que utilizaremos en nuestro simulador.

** Explicación Método de Euler semi-implícito

La ecuación del método de Euler semi-implícito se basa en la serie de Taylor, la segunda ley de Newton y la idea conceptual que las fuerzas se mantienen para el siguiente paso de tiempo, como se menciona en el apartado anterior.

A continuación, realizaremos una serie de pasos para demostrar cómo se llega a la ecuación del método Euler semi-implícito. Partimos de la conocida ecuación de la segunda ley de Newton que establece que las aceleraciones que experimenta un cuerpo son proporcionales a las fuerzas que le afectan:
\[
\sum\mathbf{F} = m \cdot \mathbf{a}
\]
El otro instrumento matemático que utilizaremos es la serie de Taylor, que nos permite aproximarnos a las funciones mediante una serie de potencias o suma de potencias enteras de polinomios que se prolonga hasta el infinito, donde cada uno de los sumandos está elevado a una potencia mayor al precedente como se muestra en la siguiente ecuación:

#+NAME: ec:taylor1
\begin{equation}
F(x) = f(a) + \dfrac{f’(a)}{1!} (x-a) + \dfrac{f’’(a)}{2!} (x-a)^2 + \dots
\end{equation}

Considerando que la variable independiente $x$, como el tiempo, tal como se ha mostrado en la ecuación anterior, y teniendo en cuenta que el valor conocido es en el instante de tiempo actual, podemos decir que el valor de $\mathbf{F}$ en el siguiente paso satisfará la reasignación de variables. Por lo que la expresión anterior quedaría como:

#+NAME: ec:taylor2
\begin{equation}
F(t_{n+1}) = f(t_n) + \dfrac{f’(t_n)}{1!} (t_{n+1}-t_n) + \dfrac{f’’(t_n)}{2!} (t_{n+1} - t_n)^2 + \dots
\end{equation}

Como es sabido, la derivada de la posición respecto del tiempo es la velocidad, al igual que la derivada de la velocidad es la aceleración, así pues, podemos calcular la nueva velocidad y posición utilizando la formulación recogida en la ecuación [[ec:taylor2]].

Se puede despejar la serie de Taylor como mostramos a continuación:

\[
s(t_{n+1}) = s(t_n) + v(t_n) \cdot (t_{n+1} -  t_n) + \dfrac{1}{2} a(t_n) \cdot (t_{n+1} – t_n)^2
\]
\[
v(t_{n+1}) = v(t_n) + a(t_{n}) \cdot (t_{n+1} -  t_n)
\]
\[
s(t_{n+1}) = s(t_n) + v(t_n) \cdot \Delta t + \dfrac{1}{2} a (t_n) \cdot (\Delta t)^2
\]
\[
v(t_{n+1}) = v(t_n) + a(t_{n}) \cdot \Delta t
\]

Por lo que se obtienen las expresiones del método de Euler explícito de segundo orden. Sin embargo, nosotros vamos a utilizar el semi-implícito, por lo que habrá que realizar operaciones sobre la ecuación de posición y velocidad para obtener las expresiones válidas. Como indicamos en el apartado anterior, el método semi-implícito conjuga aceleraciones del siguiente paso para obtener la nueva velocidad y utiliza tanto la nueva velocidad como la aceleración para calcular la nueva posición. Así pues, las expresiones que nos van a permitir calcular estas magnitudes a través del método semi-implícito de Euler de segundo orden son:
\begin{align*}
F_n &= m \cdot a_n \\
F_n &= F_{n+1} \\
a_n &= \dfrac{F_n}{m} \\
a_{n+1} &= a_n \\
v_{n+1} &= v_n + a_{n+1} \cdot \Delta t \\
s_{n+1} &= s_n + v_{n+1} \cdot \Delta t + \dfrac{(a_{n+1} \cdot \Delta t^2)}{2}
\end{align*}

Estas ecuaciones han de ejecutarse en orden, ya que la posición depende de la velocidad y la aceleración, la velocidad depende de la aceleración y la aceleración se puede calcular siempre que supongamos que las fuerzas para el siguiente instante de tiempo son iguales. Recordemos que estas operaciones van a dar resultados precisos si los $\Delta t$ son relativamente bajos, del orden de milisegundos.

** Introducción                                                   :noexport:

La ecuación de NS tiene dependencia espacial y temporal. La componente espacial, esto es, el gradiente, el laplaciano y la densidad la calculamos mediante el método SPH, descrito en el capítulo [[*Fundamentos del Método SPH]]. Sin embargo, la componente temporal, evidenciada mediante la derivada sustantiva, requiere de un tratamiento específico no contemplado en el método SPH. Para tal fin se utilizan otros métodos numéricos tanto explícitos como implícitos, en Modak et al. [cite:@Modak-Sotelino02] se realiza una descripción de las diferentes metodologías. En nuestro proyecto nos vamos a centrar en los métodos explícitos y semi-implícitos algunos de los cuales procederemos a describir a continuación.

- Método de Euler: es el método más simple de integración temporal. Consiste en calcular las nuevas posiciones y velocidades de las partículas a partir de las velocidades y aceleraciones actuales utilizando las ecuaciones de movimiento. Sin embargo, este método tiene una baja estabilidad temporal y suele ser utilizado solo para problemas simples.

- Método de Euler semi-implícito: es una variante del método de Euler que se utiliza para mejorar la estabilidad temporal. Consiste en calcular las nuevas posiciones de las partículas a partir de las velocidades actuales y las aceleraciones interpoladas, mientras que las nuevas velocidades se calculan a partir de las aceleraciones actuales.

- Método de Verlet: es un método de integración temporal que se basa en el uso de la posición actual y la posición anterior para calcular la velocidad y la nueva posición de las partículas. Es un método más estable que el método de Euler y se utiliza comúnmente en SPH.

** Ecuación fundamental para la integración temporal numérica     :noexport:

La idea subyacente en la integración temporal numérica es la de dividir el tiempo en pequeños intervalos (llamados pasos de tiempo) y calcular la solución en cada uno de estos intervalos. En cada paso de tiempo, se utilizan las condiciones iniciales (como la posición y velocidad de las partículas) y las ecuaciones de movimiento para calcular la solución en el siguiente paso de tiempo. Esto se repite sucesivamente para todos los pasos de tiempo, generando una serie de soluciones que representan la evolución del sistema en el tiempo.

Así, la discretización temporal numérica consiste en aproximar la solución de un sistema dinámico (como las ecuaciones de movimiento) mediante una serie de pasos discretos en el tiempo.

La precisión de la solución numérica dependerá del tamaño del paso de tiempo elegido y del método de integración temporal utilizado. Los métodos de integración temporal más precisos son los de orden superior, como el método de Runge-Kutta, que utilizan más información para calcular la solución en cada paso de tiempo, pero son también más computacionalmente costosos, lo cual limita su uso en la simulación de fluidos dentro del ámbito de CG.

En resumen, la integración temporal numérica busca aproximar la solución de un sistema dinámico dividiendo el tiempo en pequeños intervalos y utilizando las condiciones iniciales y las ecuaciones de movimiento para calcular la solución en cada paso de tiempo. La precisión de la solución depende del tamaño del paso de tiempo y del método de integración temporal utilizado.

(Ecuaciones)

** Comparativa entre métodos implícitos y explícitos              :noexport:

En la integración temporal numérica, los métodos implícitos y explícitos se refieren a cómo se utilizan las soluciones en un paso de tiempo para calcular la solución en el siguiente paso de tiempo.

Los métodos explícitos son aquellos en los que las soluciones en un paso de tiempo son utilizadas directamente para calcular la solución en el siguiente paso de tiempo. Es decir, las soluciones en un paso de tiempo no afectan a las soluciones en el siguiente paso de tiempo. Los métodos explícitos son fáciles de implementar y rápidos, pero su estabilidad temporal esta limitada por el tamaño del paso de tiempo. Ejemplos de métodos explícitos son el método de Euler, Verlet.

Por otro lado, los métodos implícitos son aquellos en los que las soluciones en un paso de tiempo son utilizadas para calcular las soluciones en el siguiente paso de tiempo de manera implícita, a través de la resolución de un sistema de ecuaciones no lineales. Estos métodos son más estables temporalmente, pero requieren más cálculos y son más complejos de implementar. Ejemplo de métodos implícitos son los métodos de Runge-Kutta, Euler-implícito.

En resumen, la diferencia entre los métodos implícitos y explícitos de integración numérica radica en cómo se utilizan las soluciones en un paso de tiempo para calcular la solución en el siguiente paso de tiempo. Los métodos explícitos son fáciles de implementar y rápidos pero con menor estabilidad temporal, mientras que los métodos implícitos son más estables temporalmente pero más complejos de implementar.

* Colisiones

En el mundo real los fluidos interactúan con objetos y debido a esta interacción se modifica su comportamiento dinámico. Cuantitativamente, la interacción o colisión del fluido con objetos se modela imponiendo restricciones tanto a las variables de estado como a las magnitudes dinámicas. Estas restricciones son conocidas como condiciones de contorno y son las responsables de alterar el flujo del fluido descrito por la ecuación NS.

Al tratar en nuestro proyecto con la metodología SPH que trata el conjunto de nuestro fluido como partículas independientes, se puede suponer que la forma geométrica de estas partículas será la de un punto o, de una forma más compleja, la de una esfera, ya que las operaciones para detectar que una partícula (punto o esfera) ha colisionado con un sólido rígido son análogas. Sólo que cuando se considera como una esfera habrá que tener en cuenta el radio.

Hay un consenso en dividir la colisión en dos partes, la primera es la detección la segunda es la respuesta. En la detección se realizan operaciones vectoriales cuyo objetivo es determinar la distancia relativa entre las partículas y los objetos con los que puede colisionar. En caso de que se detecte colisión, se ``activa'' la segunda etapa. En la segunda etapa, la etapa de respuesta, se realizan operaciones sobre las magnitudes dinámicas y variables de estado de la partícula de modo que satisfagan las condiciones de contorno.

** Detección de la colisión

Dependiendo de la simetría del contorno, el proceso de detección puede simplificarse, tal como describiremos a continuación. En nuestro simulador distinguiremos entre dos tipos de contornos, los de alta simetría geométrica, relativamente fáciles de operar en la detección, y los que tienen una geometría más compleja, que normalmente están discretizados mediante triángulos. En las siguientes secciones vamos a realizar una descripción de las distintas técnicas de detección utilizadas.

*** Colisión con cuerpos rígidos con alta simetría

A continuación, se desarrollará una explicación sobre las diferentes colisiones que puede tener una esfera, ya que en nuestro simulador cada partícula es tratada geométricamente como una esfera, con otros cuerpos rígidos.

**** Colisión partícula-caja

Para saber si una esfera (o partícula en nuestro caso) ha colisionado con un cuerpo geométrico con la forma de un cubo o hexaedro rectangular, que en lo sucesivo designaremos como hexaedro, debemos tener en cuenta que, dado que el hexaedro tiene todos sus lados perpendiculares, podemos considerar los límites de sus dimensiones como los valores a evaluar.

Es decir, conociendo tres aristas perpendiculares entre sí se pueden obtener los límites inferiores y superiores de cada dimensión con los que puede colisionar la partícula.

Una vez conocidos estos límites, podemos determinar si la posición de nuestra partícula se encuentra dentro o fuera de la figura geométrica.

Si suponemos que la partícula se encuentra en movimiento en el interior del hexaedro, podemos determinar que la partícula ha colisionado con una de las caras, cuando alguna de las coordenadas de su posición se encuentre /fuera/ de los límites calculados anteriormente.

Análogamente, si suponemos que la partícula se encuentra en el exterior, seguiríamos necesitando los mismos parámetros para definir nuestro hexaedro, pero esta vez la colisión se detectaría si los valores de la posición de la partícula estuvieran /dentro/ de esos límites.

#+CAPTION: Colisión caja
#+ATTR_LATEX: :width 8cm
[[./graficos/caja-vacia.pdf]]

Por tanto, al implementar un procedimiento de detección de la colisión de una partícula con un hexaedro se deberá tener en cuenta la posición inicial de la partícula.

En este trabajo, nos centraremos en explicar el caso en el que la partícula se encuentra dentro del hexaedro, ya que nos resultará muy conveniente, al permitirnos representar un fluido contenido en un espacio cerrado.

El algoritmo que se utilizará para determinar las colisiones deberá respetar las restricciones anteriores que se sintetizan en las siguientes expresiones lógicas:
\begin{align*}
(P_x < \lim X_{inf} &\lor P_x > \lim X_{sup})\; \lor \\
(P_y < \lim Y_{inf} &\lor P_y > \lim Y_{sup})\; \lor \\
(P_z < \lim Z_{inf} &\lor P_z > \lim Z_{sup})
\end{align*}

**** Colisión partícula-cilindro

Otro de los objetos con alta simetría geometría es el cilindro. Los parámetros que tendremos en cuenta en este caso son su altura, el radio y el eje.

En este caso, primero habrá que determinar si la distancia de la partícula al eje es menor que el radio. Seguidamente, en caso de que esta restricción se cumpla, se tiene que comprobar si la posición de la partícula es compatible con la altura del cilindro.

Finalmente, cuando ambas condiciones se satisfagan, entonces podremos asegurar que la partícula habrá colisionado con el cilindro.

El algoritmo que se utilizará para determinar las colisiones deberá respetar las restricciones anteriores  que se sintetizan en las siguientes expresiones lógicas:
\[
(P_y < \lim Y_{inf} \lor P_y > \lim Y_{sup}) \land (\text{distancia} < \text{radio})
\]
siendo la distancia la magnitud del vector entre la posición de la partícula y el eje del cilindro, representada matemáticamente en la siguiente ecuación:
\[
\text{Distancia} = \left|(P_x - \text{eje}_x, 0, P_z - \text{eje}_z)\right|
\]

#+CAPTION: Colisión cilindro
#+ATTR_LATEX: :width 8cm
[[./graficos/cilindro.pdf]]

**** Colisión partícula-esfera

La colisión partícula-esfera es la más fácil de implementar, ya que sólo se tiene que comprobar si la distancia que separa la esfera y la partícula es inferior o superior, dependiendo de si la colisión es exterior o interior, al radio de la esfera. Así pues, los únicos parámetros que tenemos que tener en cuenta son el radio y el centro de la esfera con la que se va a colisionar. Al conocer estos parámetros solo necesitaríamos aplicar una operación vectorial que nos calcule el módulo o distancia entre nuestra partícula y el centro de la esfera. Una vez obtenida esa distancia, se debe comprobar si la distancia es menor que el radio de la esfera. Si el resultado es afirmativo, sabremos que la partícula habrá colisionado con la esfera.

#+CAPTION: Colisión esfera
#+ATTR_LATEX: :width 8cm
[[./graficos/esfera.pdf]]

El algoritmo que se utilizará para determinar la colisión se ajustará a la restricción planteada en la siguiente expresión lógica:
\[
(\text{distancia} < \text{radio})
\]
donde la distancia es la magnitud entre la posición de la partícula y el centro de la esfera, representada matemáticamente en la siguiente ecuación:
\[
\text{Distancia} = \left|(P_x - C_x, P_y - C_y, P_z - C_z)\right|
\]
*** Colisión con contorno discretizado en triángulos

La mayoría de los modelos existentes no son figuras geométricas con alta simetría, que tienen la característica de que sus colisiones son fáciles de calcular e implementar, sino que son mallas de cuadrados o de triángulos que permiten formar todo tipo de figuras. Sin embargo, en el ámbito de CG, el estándar es que los modelados sean mallas de triángulos, por ser el polígono que mejor se adapta a contornos complejos y resulta más fácil de operar vectorialmente. Por ello, en este estudio, nos centramos únicamente en triángulos.

La principal desventaja que presenta un objeto complejo es su alto número de triángulos, lo que va a reducir la eficiencia computacional, ya que de los 12 triángulos en los que se puede discretizar una caja se puede pasar a los 69.451 triángulos que conforman el contorno del /Stanford bunny/.

#+CAPTION: Stanford bunny triángulos
#+ATTR_LATEX: :width 8cm
[[./graficos/caja-conejo.pdf]]


**** Colisión partícula-triángulo

La colisión partícula-triángulo es más costosa computacionalmente que las que hemos descrito con objetos de alta simetría geométrica, ya que requiere de una gran cantidad de operaciones matemáticas para calcular si la partícula ha colisionado o no con un triángulo. A pesar de ello, como hemos explicado anteriormente, los modelos discretizados por triángulos son ampliamente utilizados, al igual que la técnica de detección de una colisión con un triángulo también lo es.

Los parámetros necesarios para conocer si existe la colisión entre una partícula y un triángulo, en un espacio 3D, son los vértices del triángulo y la posición de la partícula.

#+CAPTION: Colisión triángulo
#+ATTR_LATEX: :width 8cm
[[./graficos/triangulo.pdf]]

Seguidamente explicaremos la secuencia de pasos necesarios para calcular si una partícula ha colisionado con un triángulo. Esta secuencia es la que tendríamos que aplicar a cada uno de los triángulos que conforman el modelo discretizado en triángulos.

Este proceso, denominado campo de distancia, nos permite determinar si existe colisión entre la partícula y el triángulo independientemente de la orientación y posición en la que se encuentre el triángulo.

El primer paso consiste en determinar si la partícula está a una distancia en la que es posible que colisione con el triángulo. Para ello, se debe realizar secuencialmente las siguientes tareas:

1. Determinar la posición de cada vértice del triángulo y la posición de la partícula en el instante de la posible colisión. Para ello, escogemos dos aristas del triángulo y calculamos el producto vectorial de esos dos vectores. Como resultado obtenemos un vector perpendicular al triángulo. El módulo de dicho vector perpendicular nos da el área del paralelogramo que definen ambos vectores, según la expresión matemática $|\mathbf{b} \times \mathbf{c}| = |\mathbf{b}||\mathbf{c}||\sin \theta|$, tal como se ilustra en la figura [[fig:triangulo01]].

   #+NAME: fig:triangulo01
   #+CAPTION: Producto vectorial
   #+ATTR_LATEX: :width 10cm
   [[./graficos/producto-vectorial.pdf]]

2. Obtener el vector posición de nuestra partícula que tiene origen en el vértice del que nacen nuestros vectores o aristas elegidos. Como vemos en la figura  [[fig:triangulo02]].

   #+NAME: fig:triangulo02
   #+CAPTION: Representación del vector distancia desde el vértice elegido hacia la partícula
   #+ATTR_LATEX: :width 10cm
   [[./graficos/producto-triangulo.pdf]]

3. Calcular el producto escalar del vector resultante del producto vectorial y el vector posición de la partícula. La magnitud de este producto escalar representa el volumen de un paralelepípedo imaginario, cuya altura representa la distancia vertical de la partícula respecto al plano.

   Si la altura de ese paralelepípedo es menor una distancia determinada, en la que es posible que nuestra partícula colisione, entonces se debe comprobar si la partícula y el triángulo se intersecan.

Una vez realizadas estas tareas, que han permitido conocer si la partícula está a una distancia del triángulo en la que es posible colisionar, debemos determinar, en un segundo paso, si la partícula ha colisionado con nuestro triángulo. Para ello, necesitamos proyectar la posición de nuestra partícula en la superficie o plano.

La proyección de un punto sobre un plano, respetando las propiedades que lo definen, se describe mediante la siguiente fórmula:
\[
P_{pr} = \Biggl(\biggl(P_x + \dfrac{\text{altura}}{\text{superficie}}\biggr) S_x, \biggl(P_y + \dfrac{\text{altura}}{\text{superficie}}\biggr) S_y, \biggl(P_z + \dfrac{\text{altura}}{\text{superficie}}\biggr) S_z\Biggr),
\]
donde $P$ es la posición de la partícula, altura es la distancia de nuestra partícula al plano, superficie es la magnitud del producto vectorial que define el plano y $S$ es el producto vectorial.

#+NAME: fig:triangulo03
#+CAPTION: Representación del punto proyectado sobre el plano
#+ATTR_LATEX: :width 10cm
[[./graficos/triangulo-punto.pdf]]

Una vez proyectada la posición de la partícula, será necesario comprobar si la partícula está dentro del triángulo. El proceso que utilizaremos para calcular si el punto se encuentra en el interior del triángulo se basa, en calcular el producto escalar entre los vectores que se forman al unir el punto proyectado con los vértices del triángulo, lo que permite obtener los tres ángulos que se forman entre ellos, aplicando la expresión que relaciona un ángulo con el producto escalar de sus lados:
\[
\theta = \cos^{-1} \left( \frac{\mathbf{A}\cdot\mathbf{B}}{|\mathbf{A}||\mathbf{B}|}\right)
\]
Si la suma de los tres ángulos es igual a 2\pi, podemos determinar que el punto proyectado se encuentra dentro del triángulo y, por tanto, que la partícula ha colisionado.

#+NAME: fig:triangulo04
#+CAPTION: Representación del punto proyectado junto con las aristas interiores apuntando hacia los vértices
#+ATTR_LATEX: :width 10cm
[[./graficos/triangulo-punto2.pdf]]

** Respuesta de la colisión

Una vez que se ha detectado que la partícula ha colisionado, independientemente de la simetría del contorno, el siguiente paso es aplicar la respuesta a la colisión. Es decir, imponer las condiciones de contorno, que modificarán las magnitudes dinámicas y las variables de estado, para evidenciar la interacción.

En un primer momento se puede llegar a pensar que, al igual que en la colisión, podemos llegar a necesitar varias respuestas para diferentes cuerpos geométricos. Sin embargo, se puede estandarizar la respuesta de la colisión para los diferentes tipos de detecciones con figuras geométricas como cubos, esferas, cilindros o detecciones de modelos que usan triángulos. Este proceso de estandarización se puede llevar a cabo siempre que almacenemos en la estructura de nuestros modelos, ya sean mallas de triángulos o figuras geométricas con alta simetría, los vectores normales de los planos con respecto a la dirección que queremos que interactúe la partícula.

Remarcar también que la técnica que se explica a continuación está avalada por diferentes autores como Di Monaco et al. [cite:@MonManGal.etal11], Li et al. [cite:@li2014efficient] o Perea et al. [cite:@Perea-Cordero18]

Esencialmente, el proceso que se sigue tiene como objetivo calcular la nueva velocidad de la partícula después de la colisión y rectificar su posición.

Este cálculo se lleva a cabo mediante la realización de varias operaciones vectoriales que nos permitirán conocer el vector resultante de la velocidad a asignar. Además, también necesitaremos algunos parámetros adicionales, como la tasa de rozamiento y de rebote, ya que tendrán influencia en nuestra velocidad final.

El primer paso que debemos realizar es obtener la velocidad incidente al detectarse la colisión. Una vez conocida esta velocidad, se procede a calcular la proyección de este vector sobre el vector normal almacenado. Seguidamente, se calcula la velocidad tangencial que es el resultado de restar la velocidad proyectada a la velocidad inicial. Esta velocidad tangencial debe ser modificada para tener en cuenta el rozamiento de la partícula. Para ello, habrá que multiplicar el vector por una tasa de rozamiento determinada.

Por otro lado, el vector normal de la partícula se obtendrá multiplicando el vector proyectado por una tasa de rebote, lo que resultará en que su dirección sea contraria a la del vector proyectado.

La suma de la velocidad tangencial modificada y la velocidad normal modificada dará como resultado la velocidad final que asignaremos a nuestra partícula, como se ilustra en la figura [[fig:fases]].

#+NAME: fig:fases
#+CAPTION: Representación esquemática de las tres fases para corregir la velocidad: antes de la colisión, durante la colisión y después de la colisión
#+ATTR_LATEX: :width 12cm
[[./graficos/pelotas.pdf]]

Para corregir la posición de la partícula se sigue un proceso similar. Primero, obtendremos el vector posición una vez detectada la colisión con algún sólido rígido. A este vector habrá que sumarle el vector que resulta de multiplicar el vector normal almacenado por una tasa de penetración dada, para obtener finalmente el vector de la posición rectificada. Con esto conseguimos que la partícula no siga colisionando con el plano.

#+CAPTION: Representación esquemática de la corrección de la posición después de la colisión
#+ATTR_LATEX: :width 6cm
[[./graficos/rebote.pdf]]

Esta respuesta estandarizada es extremadamente útil, ya que permite resolver uno de los principales problemas en las colisiones, como es el de tratar con colisiones múltiples, que son las que se producen al interactuar con vértices, aristas o intersecciones de diferentes cuerpos geométricos.

La suma de los vectores normales almacenados implicados en la colisión múltiple dará como resultado un vector normal, cuya dirección es coherente con lo que se espera en la realidad. Así, por ejemplo, la dirección de la respuesta de una partícula, cuando colisiona con una arista, la podemos calcular a través de la suma de los diferentes vectores normales almacenados de las caras que forman dicha arista.

Además, esta respuesta estandarizada también va a permitirnos implementar diferentes métodos de detección de colisiones, lo que implica una mayor versatilidad y escalabilidad.

* Características de las herramientas de implementación del proyecto

** Características del lenguaje C

Como ya hemos visto, nuestro proyecto de simulación de fluidos se ha construido sobre dos librerías para unos resultados iniciales que luego se exportaran a un motor de renderizado.

Debido a que el objetivo de este proyecto se ha enfocado en reducir lo máximo posible el tiempo de cálculo necesario para el muestreo de los resultados. Se ha utilizado el lenguaje C debido a las siguientes razones. Tanto CUDA como OpenGL tienen soporte en C cuya incorporación en este mismo lenguaje está documentado, mantenido y siendo usado por varios desarrolladores.

C también es, por sí solo, uno de los lenguajes multiplataforma que permite una gran eficiencia del código y es el más utilizado actualmente en el desarrollo de software. Además de permitir estructuras típicas de los lenguajes de alto nivel,  también nos da acceso a funciones de control de bajo nivel, como puede ser el manejo de la memoria. Todas estas características nos resultarán muy útiles a la hora de desarrollar nuestro proyecto.

** Características del lenguaje-arquitectura CUDA

*** Introducción

Seguidamente se va a presentar la herramienta sobre la que se fundamenta uno de los pilares de este proyecto el cual es la mejora de rendimiento del simulador, puesto que el coste computacional es uno de los mayores problemas en el ámbito de las /Computer Graphics/. Para solventar este problema se ha decidido utilizar CUDA para acelerar los cálculos. Por ello vamos a hacer una introducción sobre lo que es CUDA y cómo opera.

CUDA acrónimo en ingles de /Compute Unified Device Architecture/ es el nombre de la arquitectura desarrollada por NVIDIA (una de las desarrolladoras más importantes de tarjetas gráficas) para sus tarjetas gráficas. El objetivo de esta arquitectura es hacer asequible las tarjetas gráficas a cualquier programador a través de lenguajes de alto nivel y así poder utilizarlas para realizar cómputos de propósito general, mediante procesamiento en paralelo. Esto quiere decir que podemos desarrollar aplicaciones que aprovechen el potencial de la arquitectura CUDA a través de lenguajes de alto nivel como pueden ser C, OpenCL, Fortran, C++, DirectX Compute, Python…

#+CAPTION: Arquitectura CUDA
#+ATTR_LATEX: :width 8cm
[[./graficos/cuda-arquitectura.pdf]]

*** Arquitectura CUDA

A continuación, vamos a describir como se compone físicamente una GPU (/Graphic Processing Unit/) CUDA.

Una GPU CUDA está formada por varios multiprocesadores, cada uno de ellos está constituido por distintos espacios de almacenamiento y cientos de núcleos de cómputo, estos núcleos de cómputo son los encargados de ejecutar las instrucciones. Estableciendo similitudes, se podría decir que son similares a una ALU en un procesador tradicional. Cada uno de estos núcleos de cómputo según la terminología de CUDA son llamados CUDA cores.

#+CAPTION: Representación esquemática de la arquitectura de una tarjeta gráfica NVIDIA. /NVIDIA CUDA Developer Guide/
#+ATTR_LATEX: :width 14cm
[[./graficos/cuda-core.pdf]]

Una tarjeta gráfica con arquitectura CUDA se puede clasificar como un computador con arquitectura SIMD (/Single Instruction Multiple Data/), es decir, un flujo único de instrucciones un flujo múltiple de datos. Esto permite aprovechar el paralelismo de datos dentro de una aplicación, ya que todos los núcleos de la GPU ejecutan la misma instrucción sobre datos distintos, esta característica fue una de las claves para decidir usar CUDA sobre otras herramientas ya que en el ámbito de las CG y  en nuestro caso una simulación lagrangiana con magnitudes altas en el número de partículas, siempre vamos a utilizar las mismas operaciones sobre estas lo que en un sistema tradicional requeriría un alto coste computacional, ya que tiene que ejecutar estas operaciones de manera secuencial sobre cada partícula, usando CUDA nos permite ejecutar estas mismas operaciones de manera paralela.

Esta ventaja de paralelismo también se aplica sobre diferentes aplicaciones, ya que permite incrementar el rendimiento aprovechando las altas prestaciones de una GPU para realizar cálculo paralelo.

Se debe remarcar, también, que éste es un modelo de computación heterogéneo formado por una CPU y GPU.

#+CAPTION: Comparativa del número de núcleos de entre una CPU (4) y una GPU (240)
#+ATTR_LATEX: :width 8cm
[[./graficos/cores.pdf]]

En este modelo computacional la CPU se encarga de ejecutar la parte secuencial de la aplicación mientras que la GPU se ocupa de la parte paralela.

*** Programación en CUDA

En las secciones anteriores hemos revisado la composición de la arquitectura CUDA y, en esta sección nos vamos a centrar en hacer una breve introducción sobre cómo se programa en una tarjeta gráfica que no posee una arquitectura CUDA y cómo esta última presenta ventajas ante las otras.

El problema de programar en una tarjeta gráfica tradicional, para cómputos de propósito general, es que se necesita utilizar lenguajes de programación específicos para gráficos, como son OpenGL o Cg, para programar en la GPU. Esto implica que el desarrollador debe modificar su aplicación para que convirtiera su problema en uno que dibujara triángulos o polígonos, esto limito el uso de las GPUs como parte intrínseca del desarrollo de aplicaciones de propósito general.

Las tarjetas gráficas con arquitectura CUDA, por otro lado, se pueden programar utilizando CUDA C/C++. Éste es un pequeño conjunto de extensiones del lenguaje C/C++, que nos permite empezar a programar sobre una tarjeta gráfica teniendo conocimientos de programación en C. Además, NVIDIA, la empresa desarrolladora de las GPUs con arquitectura CUDA, proporciona un compilador y un conjunto de herramientas de desarrollo que facilitan el proceso de creación de aplicaciones.

El principal problema de CUDA es que sólo se puede utilizar sobre dispositivos NVIDIA. Una alternativa válida para cualquier tipo de tarjeta gráfica es utilizar OpenCL. Sin embargo, el proceso de aprendizaje de OpenCL es mucho más costoso. Por el contrario, la transición de CUDA C a OpenCL es mucho menor. Por este motivo, junto a la proliferación de las tarjetas NVIDIA en la mayoría de dispositivos y las ventajas anteriormente mencionadas, es por lo que nos hemos decidido a utilizarla sobre otras alternativas.

*** Estructura de programación en CUDA C

En las secciones anteriores se han introducido las características de un modelo de computación heterogéneo, lo que implica que un programa en CUDA C se va a diferenciar dos partes: la parte correspondiente al código que se va a ejecutar en la tarjeta gráfica, que corresponde a la función que se quiere paralelizar, y la parte correspondiente a la CPU, donde se ejecutarían funciones secuenciales y el programa principal o /main/. Este /main/ se ejecuta de forma secuencial en la CPU y, en algún momento de esa ejecución secuencial, se harán llamadas a la función que se ejecuta en la tarjeta gráfica, cuya ejecución es en paralelo. Una vez finalizada la función paralela, se volvería a la parte secuencial de nuestro código que se terminaría de ejecutar en la CPU (ver figura [[fig:prog-heterogenea]]).

#+NAME: fig:prog-heterogenea
#+CAPTION: Modelo de programación heterogénea
#+ATTR_LATEX: :width 10cm
[[./graficos/prog-heterogenea.pdf]]

Para terminar de entender cómo se ejecuta CUDA C es importante conocer su terminología básica:

- Host: CPU y su memoria.
- Device: GPU y su memoria.
- Kernel: Función principal que se ejecuta en el device.
- Hilo (thread): Cada una de las copias del kernel que se ejecuta en el device (figura [[fig:thread]]).

  #+NAME: fig:thread
  #+CAPTION: Thread
  #+ATTR_LATEX: :width 6cm
  [[./graficos/thread.pdf]]

- Bloque (Block): Conjunto de hilos (figura [[fig:block]])

  #+NAME: fig:block
  #+CAPTION: Block
  #+ATTR_LATEX: :width 6cm
  [[./graficos/block.pdf]]

- Malla (Grid): Conjunto de bloques (figura [[fig:grid]])

  #+NAME: fig:grid
  #+CAPTION: Grid
  #+ATTR_LATEX: :width 8cm
  [[./graficos/grid.pdf]]

Análogamente, se puede entender, desde el punto de vista del hardware, cómo se agrupa la memoria en CUDA. Correspondiendo así un hilo que se ejecuta en un CUDA core, un bloque que se ejecuta en un CUDA Streaming Multiprocessor y una malla que se reparte entre todos los multiprocesadores con los que cuente la tarjeta gráfica.

Una vez ya explicada la estructura que posee un programa en CUDA hay que analizar cómo se comparten datos entre el host y el device.

En primer lugar, se copian los datos desde la memoria de la CPU hacia la memoria de la GPU. El siguiente paso consiste en cargar el código de la función kernel en la GPU, que se ejecutará en paralelo en tantos hilos como se haya decidido. Estos hilos comparten los datos de la memoria de la tarjeta gráfica. Una vez finalizada la ejecución del Kernel, se copian los resultados desde la memoria de la GPU a la memoria de la CPU.

** Características de OpenGL

Una librería gráfica es un conjunto de programas que implementan versiones optimizadas de funciones y métodos, lo cuales facilitan al programador la renderización de gráficos para mostrarlos en un dispositivo electrónico de salida de vídeo, ya sean monitores de computadora o cascos RV. Así mismo, en una librería gráfica, se incluyen rutinas de gestión de texturas, de generación de efectos de iluminación y sombreado, y que pueden aprovechar hardware de las actuales tarjetas gráficas

Existen diferentes librerías gráficas de bajo nivel, es decir, aquéllas que permiten sacar el máximo partido al hardware, aunque también son las más complejas de programar. De entre estas se pueden destacar, debido a su amplio uso en el sector de la computación gráfica, Vulkan, DirectX y OpenGL. Todas ellas tienen sus ventajas e inconvenientes y, según ciertos aspectos, destacan unas sobre otras. En este proyecto, para una ilustración previa de los resultados, se ha utilizado OpenGL.

OpenGL no es solo una API o una librería, sino una especificación de ciertas funciones, que tienen que devolver cierto tipo de resultados. Para ello, se han desarrollado varias librerías, normalmente, por los creadores de las tarjetas gráficas (/OpenGL Utility Toolkit/ - GLUT, /Simple DirectMedia Layer/ - SDL, /Simple and Fast Multimedia Library/ - SMFL o /Graphics Library Framework/ - GLFW), que deben ser implementadas conforme a las especificaciones de OpenGL. Esto ha llevado a que la implementación de OpenGL pueda tener comportamientos extraños, debido a incompatibilidades con algunas tarjetas gráficas o la falta de mantenimiento de ciertas librerías por parte de sus desarrolladores.

GLFW (/Graphics Library Framework/) es una pequeña librería en C que permite la creación y gestión de ventanas con contextos OpenGL, haciendo posible también el uso de múltiples monitores y modos de vídeo. También, proporciona acceso a la entrada del teclado, ratón y joysticks. La API proporciona una fina capa de abstracción multiplataforma, principalmente para aplicaciones cuya única salida gráfica es a través de la API OpenGL. Aunque GLFW es muy útil cuando se desarrollan aplicaciones OpenGL multiplataforma, los desarrolladores de una sola plataforma también pueden beneficiarse de su uso, al evitar tener que lidiar con diferentes API específicas de la plataforma.

En este proyecto se utiliza la librería GLFW debido a la disponibilidad de gran cantidad y calidad de recursos didácticos con los que cuenta esta librería como, por ejemplo, para desarrollar implementaciones de los conceptos de OpenGL. Todo este material se ha tenido que investigar desde cero, para la realización de un muestreo de resultados inicial.

* Estructura del simulador y resultados
** Introducción

A lo largo de los capítulos anteriores, hemos expuesto la importancia que tiene la simulación de fluidos en el ámbito de CG. Además, se ha realizado un análisis previo, desde el punto de vista de un desarrollador, del proyecto que se quiere implementar. En nuestro caso, se trata de una simulación de fluidos basada en física, donde hemos realizado un recorrido por los fundamentos matemáticos necesarios y las técnicas existentes, capaces de simular un fluido de manera realista y versátil. Se han estudiado los trabajos de aquellos autores que avalan estas técnicas y, finalmente, se ha seleccionado una técnica concreta. Igualmente, se ha explicado el concepto de la búsqueda de vecinas, sin el cual, no se puede realizar el método de simulación escogido. También, se explicaron y analizaron los diferentes tipos de búsqueda existentes, y se expuso el motivo por el que se ha seleccionado uno sobre los otros. Seguidamente, se introdujeron los métodos de integración temporal y las razones por las que se necesitan en la simulación basada en física en general, y la de fluidos en particular. Así mismo, se ha establecido la importancia de que el fluido sea capaz de reaccionar ante sólidos rígidos para que éste cumpla el requisito de simulación realista, así como las diferentes técnicas que podemos implementar para que el fluido reaccione a su entorno. Por último, se han explicado las herramientas que se han utilizado en el desarrollo de este proyecto, así como aquellas características que las distinguen favorablemente frente a otras herramientas similares. Después de haber explicado todos los pormenores que conlleva la realización de un simulador de fluidos basado en física, y comprender todas las piezas necesarias para construirlo, en este capítulo vamos a exponer cómo se ha llevado a cabo este desarrollo y la estructura interna que tiene el simulador.

** Diagrama de Clases

El lenguaje CUDA C tiene como particularidad que alcanza su máximo rendimiento cuando no utiliza una estructura orientada a objetos. Para aprovechar esta característica, no contaremos con un diagrama de clases al uso, ya que no vamos a trabajar con clases. No obstante, seguimos necesitando almacenar información en el simulador, por lo que vamos a representar sus funciones y variables más importantes como pseudo-clases, junto con los tipos de datos que se ingresan y devuelven.

A continuación, se hace una relación de las pseudo-clases que hemos utilizado en la elaboración de nuestro proyecto.

- /Partícula/: Es una estructura (/struct/) que nos almacena la posición, velocidad, aceleración y masa de cada partícula, además de almacenar la fuerza interna, también almacena un indicador de si ha colisionado junto con un array de vecinas y su número.

- /Esfera/: Es una estructura (/struct/) en el que guardamos la posición y radio de la esfera.

- /Caja/: Es una estructura (/struct/) en la que guardamos los límites que definen a un hexaedro y su posición (centro de la caja).

- /Cilindro/: Es una estructura (/struct/) en la que guardamos el eje y límite que definen un cilindro junto con su posición (centro del cilindro).

- /Modelo/: Es una estructura (/struct/) que nos almacena modelos formados por triángulos, guardando sus vértices, aristas y normales.

- /MetodoEulerSemImplcito/: Este es el método encargado de recalcular las nuevas velocidades y posiciones del conjunto de partículas que recibe, a través de la aceleración y el paso del tiempo. Al ser una función kernel, cuyo objetivo es que se ejecute en el device, es necesario que previamente se reserve un espacio de memoria en la GPU para que este método se pueda ejecutar en paralelo.

- /respuestaColision/: Este el método que, dada una partícula y un vector normal, calcula la posición y velocidad rectificadas.

- /detectaColisionCilindro/: Este es el método que, dado un /struct/ cilindro, determina, a través de las operaciones vectoriales mencionadas en el capítulo [[*Colisiones]], si existe o no colisión con un cilindro y modifica el estado de colisión del conjunto de partículas recibidas.

- /detectaColisionEsfera/: Este es el método que, dado un /struct/ esfera, determina, a través de las operaciones vectoriales mencionadas en el capítulo [[*Colisiones]], si existe o no colisión con una esfera y modifica el estado de colisión del conjunto de partículas recibidas.

- /detectaColisionCaja/: Este es el método que, dado un /struct/ caja, determina, a través de las operaciones vectoriales mencionadas en el capítulo [[*Colisiones]], si existe o no colisión con una caja y modifica el estado de colisión del conjunto de partículas recibidas.

- /detectaColisionModelo/: Este es el método que dado un /struct/ modelo, determina, a través de las operaciones vectoriales mencionadas en el capítulo [[*Colisiones]], si existe o no colisión con un modelo formado por triángulos y modifica el estado de colisión del conjunto de partículas recibidas

- /vecinasFuerzaBruta/: Este es el método que calcula las partículas vecinas que tiene cada partícula, aplicando el método de búsqueda exhaustiva explicado en el capítulo [[*Búsqueda de partículas vecinas]]. Modifica los atributos del conjunto de partículas y almacena en ellas el número de partículas vecinas de cada una.

- /vecinasHash/: Este es el método que calcula las partículas vecinas usando la búsqueda de vecinas basada en hash explicada en el capítulo [[*Método de integración temporal]]. Modifica los atributos del conjunto de partículas y almacena en ellas el número de partículas vecinas de cada una.

- /FuncionKernel/: Calcula la función kernel asociada al método SPH, vista en el capítulo [[*Fundamentos del Método SPH]].

- /GradienteKernel/: Calcula el gradiente del kernel asociada al método SPH, visto en el capítulo [[*Fundamentos del Método SPH]].

- /LaplacianoKernel/: Calcula el laplaciano del kernel asociada al método SPH, visto en el capítulo [[*Fundamentos del Método SPH]].

- /Densidad/: Este es el método que determina la densidad del conjunto de partículas

- /fuerzaSPH/: Este es el método que calcula las fuerzas internas resultantes de aplicar el método SPH. Determina las fuerzas internas del conjunto de partículas.

- /newAcceleration/: Determina a través de las fuerzas internas, externas y la masa la nueva aceleración o cinemática de cada partícula.

- /exportador/: Dado un conjunto de partículas, exporta sus atributos en archivos binarios entendibles por motores de renderizado.

** Bucle de simulación

Una vez descritas las pseudo-clases desarrolladas para este simulador, vamos a presentar la estructura que sigue el bucle de simulación y las actividades que se llevan a cabo.

Los pasos que sigue el bucle son:

1. /Inicialización de las variables/: se definen las variables del entorno, es decir, los objetos a colisionar y los límites del espacio de nuestro simulador. También se inicializan las variables que representan los atributos iniciales de las partículas: el número de partículas, las posiciones, las velocidades y las aceleraciones iniciales, la masa, la densidad y el paso de tiempo del bucle de simulación.

2. /Cálculo de vecinas/: una vez inicializadas las variables del entorno a simular, se realiza el cálculo de las partículas vecinas, en el que se le asigna a cada partícula un número de vecinas, usando bien el método de búsqueda exhaustiva o el método de discretización del espacio usando etiquetado hash.

3. /Colisiones/: se determina si las partículas han colisionado. Para ello, se detectan las colisiones con diferentes cuerpos geométricos con alta simetría o con modelos discretizados con triángulos. Como resultado se pueden dar dos posibles estados:

   - Colisiona: en este caso, se aplica la /respuesta colisión/ que nos modifica la velocidad y la posición de la partícula, para que en el siguiente paso de tiempo no colisione.

   - No colisiona: en este caso, se calculan las fuerzas internas de cada partícula con SPH. Para ello, se necesitan las vecinas obtenidas del paso anterior. También, se calculan las nuevas aceleraciones de este paso de tiempo, utilizando la suma de fuerzas y la masa de cada partícula. En este momento, se puede decir que se ha calculado la dinámica para el fluido cuando no existe colisión.

4. /Método de Euler/: se calculan las nuevas velocidades y posiciones de las partículas a través de la aceleración, siempre que éstas no hayan colisionado.

Por último, se reinicializan las variables de posición, velocidad y densidad, y el bucle se repite.

Esquemáticamente, los puntos de ejecución que acabamos de describir se ilustran en la figura [[fig:diagrama]].

#+NAME: fig:diagrama
#+CAPTION: Bucle de simulación
#+ATTR_LATEX: :width 12cm
[[./graficos/diagrama.pdf]]

Para mejorar el rendimiento del bucle de simulación, aprovechando las posibilidades que ofrece el lenguaje CUDA C, se han paralelizado los siguientes procesos:

- Cálculo de vecinas: (/vecinasFuerzaBruta/, /vecinasHash/)
- La detección de colisiones y respuesta de colisiones: (/respuestaColision/, /detectaColisionCilindro/, /detectaColisionEsfera/, /detectaColisionCaja/, /detectaColisionModelo/)
- El cálculo de las fuerzas del fluido: (/FuncionKernel/, /GradienteKernel/, /LaplacianoKernel/, /fuerzaSPH/)
- El cálculo de las nuevas aceleraciones: (/newAcceleration/)
- El cálculo de las nuevas posiciones, velocidades, densidades y presiones: (/Densidad/, /MetodoEulerSemImplcito/)

** Resultados obtenidos

Una vez revisada la implementación que se ha llevado a cabo, se exponen a continuación los principales resultados obtenidos por nuestro simulador. Esto nos permitirá demostrar las capacidades más destacables del simulador.

*** Versatilidad

La primera característica que vamos a demostrar es la versatilidad. Recordemos, que por versatilidad queremos decir que el simulador es capaz de simular fluidos con diferentes variables de estado y propiedades constitutivas, y las simulaciones obtenidas son realistas a la vez que muestran las diferencias obtenidas.

Para probar esta característica hemos simulado tres tipos de fluidos (agua, aceite y chocolate). Para llevar a cabo esta simulación hemos utilizado los parámetros de simulación recogidos en la tabla [[tb:versatilidad]].

Con las condiciones descritas hemos obtenido sendas simulaciones, alguno de cuyos frames se muestran en la figura [[fig:versatilidad]].

# Por una parte, el simulador cumple con el requisito de versatilidad, ya que, a través de la modificación de ciertos parámetros, como la viscosidad, se pueden simular diferentes tipos de fluidos (agua, aceite o chocolate), como se muestra en los frames de la figura [[fig:versatilidad]].

#+NAME: fig:versatilidad
#+CAPTION[Comparativa de los resultados obtenidos para diferentes fluidos: agua, aceite y chocolate]: Comparativa de los resultados obtenidos para diferentes fluidos: agua, aceite y chocolate. Las imágenes de la izquierda se obtuvieron a los 1,65 segundos de simulación, los de la derecha a los 6,8 segundos.
#+ATTR_LATEX: :width 15cm
[[./graficos/versatilidad.pdf]]

# Los parámetros de viscosidad y densidad que se han utilizado en las /simulaciones de versatilidad/ se recogen en la tabla [[tb:versatilidad]].

#+NAME: tb:versatilidad
#+CAPTION[Parámetros utilizados en las simulaciones de versatilidad]: Parámetros utilizados en las simulaciones de versatilidad. En unidades del Sistema Internacional.\\
#+ATTR_LATEX: :align |l|c|c|c|
|----------------------+------+--------+-----------|
| Parámetros / fluidos | agua | aceite | chocolate |
|----------------------+------+--------+-----------|
| densidad $(\rho)$    |  1.0 |  0.836 |     1.275 |
| viscosidad $(\nu)$   | 1.01 |   81.6 |      4.76 |
|----------------------+------+--------+-----------|

*** Distintos tipos de reacciones

Por otro lado, el simulador también permite que el fluido reaccione frente a cuerpos rígidos con diferentes geometrías. En la figura [[fig:gestion-colisiones]] se muestran imágenes que presentan las reacciones de un fluido ante un cuerpo rígido con alta simetría o un modelo discretizado por triángulos.

*** Colisiones múltiples

Igualmente, otra característica destacable que se ha implementado en el simulador es la de recrear /colisiones múltiples/, es decir, poder simular cómo un fluido reacciona ante múltiples objetos en la misma simulación. Esto, también, queda ilustrado en la figura [[fig:gestion-colisiones]].

#+NAME: fig:gestion-colisiones
#+CAPTION[Comparativa de la gestión de colisiones]: Comparativa de la gestión de colisiones. Las imágenes de la izquierda se han obtenido utilizando cajas y cilindros, considerados como objetos de simetría geométrica. Las imágenes de la derecha muestran los resultados de un cilindro, considerado como objeto de simetría, y el /Stanford Bunny/ cuyo contorno está discretizado con triángulos.
#+ATTR_LATEX: :width 15cm
[[./graficos/gestion-colisiones.pdf]]


Por último, podemos asegurar que, al utilizar la arquitectura CUDA, se ha logrado aumentar el rendimiento del simulador, tal como se demuestra en la figura (...).

# (grafica)

# Y, por último, mostramos los valores óptimos utilizados en las distintas simulaciones.
#
#
#
# Valores óptimos para los parámetros de fuerzas SPH, según el estudio (cita de juan jose)
#
# (Tabla)
#
#
#
# Otros valores críticos para que la simulación sea realista
#
# (Tabla)
#
# (grafica)

* Conclusiones y trabajo futuro

En este último capítulo del trabajo de fin de grado se expondrán las conclusiones que se han obtenido durante el desarrollo de un ``Simulador de fluidos basado en física con arquitectura CUDA''.

A lo largo del proyecto se han definido como objetivos mínimos del desarrollo, la creación de un simulador de fluidos funcional, que resulte realista, versátil y que aproveche óptimamente el rendimiento del nuevo hardware de los sistemas informáticos actuales.

Para alcanzar estos objetivos se ha realizado una serie de estudios y trabajos que vamos a concretar a continuación:

- Se ha comenzado, analizando y estudiando en profundidad los distintos métodos numéricos existentes utilizados para la simulación de fluidos basada en física, seleccionando finalmente el Método /Smoothed Particles Hydrodynamics/ (SPH). Éste nos ha proporcionado el entorno numérico con el que modelar la ecuación dinámica del fluido y poder resolverla por medios computacionales. Esa resolución es la que nos da la simulación y una simulación realista y versátil. Las principales conclusiones de este estudio se han presentado en el capítulo [[*Fundamentos del Método SPH]].

- Uno de los primeros problemas que se nos presentó fue la búsqueda de partículas vecinas, que es una de las mayores debilidades del método SPH. En un primer momento, se han desarrollado en CUDA C las funciones necesarias para implementar una búsqueda exhaustiva para un número pequeño de Particles. Posteriormente, se desarrolló un método de búsqueda de vecinas, discretizando el espacio y usando etiquetado hash.

- A continuación, se necesitaba conocer las posiciones y velocidades de las partículas por lo que se estudiaron los diferentes métodos de integración temporal numérica, lo que ha permitido seleccionar e implementar en CUDA C, el que más se adecuaba a las peculiaridades de nuestro simulador: el método de Euler semi-implícito.

- Por último, era necesario contar con gestor de colisiones que se encargara de detectar las colisiones con distintas figuras geométricas y generar una respuesta realista. En su desarrollo se ha implementado una serie de funciones capaces de modificar las propiedades de las partículas que conforman el fluido simulado. Todo el conocimiento adquirido se explica en el capítulo [[*Colisiones]].

- En todo momento, se entendió que, para aumentar el rendimiento del simulador lo máximo posible, se necesitaba un conocimiento amplio y extenso de la arquitectura CUDA y el lenguaje C. Esta ha sido una de las principales tareas y que más tiempo ha consumido, ya que la disponibilidad de documentación y recursos es escasa en comparación con otros lenguajes, por tratarse de un lenguaje de uso muy específico, que permite programar directamente sobre las tarjetas gráficas de NVIDIA.

- Igualmente, se emprendió el aprendizaje de la librería OpenGL y diferentes sistemas de renderizado. Además de profundizar en los conceptos de CG. Todo este conocimiento se ha usado para la creación de un sistema de exportación de archivos, que puedan ser usados por motores gráficos comerciales.

A nivel profesional y académico, durante la realización de este proyecto he conseguido ampliar mi  nivel de conocimiento sobre CG, el sector en el que querría integrarme profesionalmente. Además, de profundizar y poner en práctica los conocimientos estudiados en varias asignaturas del grado de Ingeniería Informática y Tecnologías Virtuales, como

** Trabajo Futuro

Debido a lo ambicioso y complejo de este proyecto fin de grado, junto con el hecho de que puede considerarse un proyecto de investigación, son aplicables muchos desarrollos futuros.

- Conseguir que el simulador sea capaz de simular en tiempo real es el principal reto. Se ha conseguido una mejora de rendimiento usando arquitectura CUDA, pero sería posible incrementarlo al punto que realice gráficos a tiempo real.

- Optimizar la gestión de memoria de la GPU, sobre todo en lo referente a la búsqueda de vecinas. Para ello, se debería desarrollar una nueva función hash y realizar estudios sobre mejora de la coalescencia de datos en la memoria.

- Crear una interfaz de usuario ``amigable'', para la introducción de los parámetros de simulación.

* Referencias                                                        :ignore:
#+print_bibliography:
