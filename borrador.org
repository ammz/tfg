#+OPTIONS: author:nil
#+OPTIONS: title:nil
#+OPTIONS: date:nil
#+OPTIONS: toc:nil
# #+OPTIONS: num:nil
#+LANGUAGE: es
#+OPTIONS: ':t
#+OPTIONS: H:5
# #+EXPORT_FILE_NAME: ../tex/borrador
#+LATEX_CLASS: etea-empty
#+bibliography: references.bib
#+CITE_EXPORT: biblatex numeric
#+LaTeX_HEADER: \input{~/Sync/proyectos/tfg/tex/tfg-conf.tex}


* Portada                                                            :ignore:

#+BEGIN_SRC latex
    \begin{titlepage}
      \begin{sffamily}
        % \color{azulon}
        \begin{center}
          \begin{figure}
            \makebox[\textwidth][c]{\includegraphics[width=8cm]{logo-uloyola.png}}
          \end{figure}
          \vspace{2.5cm}
          {\Large Grado en Ingeniería Informática y Tecnologías Virtuales}\\
          \vspace{2cm}
          {\Large Trabajo Fin de Grado}
          \rule{10.5cm}{0.1mm}\\
          \bigskip
          {\Huge Simulación de fluidos}\\[10pt]
          {\Huge basada en física}\\[10pt]
          {\Huge utilizando la arquitectura CUDA}
          \vspace*{0.5cm}
          \rule{10.5cm}{0.1mm}\\
          \vspace*{0.9cm}
          {\large Autor}\\
          {\Large Antonio Moreno Talero}\\
          \vspace*{1cm}
          {\large Tutor}\\
          {\Large Juan J. Perea Rodríguez}
          \vfill
          {\large Sevilla, febrero 2023}
        \end{center}
        \color{black}
      \end{sffamily}
  \end{titlepage}

  \newpage
  \thispagestyle{empty}
  \mbox{}
  \newpage
#+END_SRC


* Contenido                                                          :ignore:

#+BEGIN_SRC latex
  \frontmatter
  \tableofcontents
  \listoffigures
  \listoftables
  \mainmatter
#+END_SRC


* Introducción

La computación gráfica o gráficos por ordenador también conocida por sus siglas en ingles CG (/Computer Graphics/) es el campo de la informática que trata de la generación y procesamiento de imágenes y gráficos mediante el uso de algoritmos y técnicas de programación. En la actualidad, es una tecnología clave para multitud de sectores, que van desde el cine, la fotografía digital, los videojuegos hasta la investigación científica, la arquitectura, la medicina o el diseño de vehículos.

El proyecto desarrollado para este Trabajo de Fin de Grado se centra en el uso de la metodología de generación de imágenes mediante un proceso de simulación. En concreto, se plantea una simulación basada en física, también designada como simulación dinámica.

La simulación de un sistema dinámico implica resolver las complejas ecuaciones en derivadas parciales con las que se describe, cuantitativamente, su comportamiento. Para llevar a cabo esta tarea, es necesario utilizar métodos numéricos que transforman esas complejas ecuaciones diferenciales en un conjunto de ecuaciones algebraicas, relativamente más sencillas de manejar e implementables en sistemas computacionales.

De forma aún más específica este proyecto se centrará en la simulación del comportamiento de los fluidos. La simulación de fluidos es una técnica utilizada en la ingeniería y en la ciencia para modelar y predecir el comportamiento de la dinámica de medios continuos, como es el caso del flujo de un fluido, en un sistema determinado. Se utiliza en una gran variedad de aplicaciones, como la simulación de procesos industriales, el diseño de aeronaves, vehículos e incluso en la predicción meteorológica.

Para que estas técnicas puedan ser utilizadas es necesario modelar la continuidad del fluido en un conjunto discreto de /entidades/ conexas.

Entre los diferentes métodos numéricos que se han desarrollado, merecen destacar, por su extenso uso: el Método de Elementos Finitos o FEM (del inglés /Finite Element Method/), el Método de los Volúmenes Discretos o DVM (del inglés /Discrete Volume Method/) o /Particles in cell/ (PIC), en la que las /entidades/ conexas son polígonos conexos que forman una malla. Por otro lado, existen técnicas que no se basan en la discretización mediante mallas. Entre este tipo de metodologías destaca el Método /Smoothed Particles Hydrodynamics/ (SPH) en el que las entidades son partículas libres que se /conectan/ directamente a través de funciones continuas decrecientes. Este último método es el que vamos a utilizar en nuestro proyecto.

Si bien se realizará una descripción más específica en el Capítulo [[*Fundamentos del Método SPH]], seguidamente se describen  algunas de las características más generales del método SPH.

La dinámica de un fluido se refiere al comportamiento del fluido y a su evolución en el espacio y el tiempo. Esto también implica dar respuesta a cómo el fluido se mueve, cómo cambia de forma o cómo cambian sus propiedades físicas.

Una de las principales ecuaciones que rigen la dinámica de los fluidos es la ecuación de Navier-Stokes, que describe cómo la velocidad, la presión y la densidad del fluido cambian con el tiempo y el espacio. Esta ecuación se basa en exclusivamente en la conservación del momento, y tiene en cuenta factores como la viscosidad, las fuerzas externas y la inercia del fluido.

Igualmente, la dinámica de un fluido también se ve afectada por la /estratificación/, que es cuando las diferentes capas de un fluido tienen distintas velocidades debido a diferencias en las propiedades del fluido, como la densidad o la viscosidad. Esto puede dar lugar a distintos fenómenos como los remolinos o las corrientes turbulentas.

Otro factor importante en la dinámica de los fluidos es la turbulencia, que es el movimiento caótico e irregular de un fluido. La turbulencia puede estar causada por factores como las diferencias de velocidad, las irregularidades en la superficie o las perturbaciones externas. El factor de la turbulencia puede tener un gran impacto en la dinámica de un fluido, ya que puede aumentar la mezcla y el intercambio de calor y masa.

En resumen, la dinámica de un fluido se refiere al comportamiento y evolución del fluido en el espacio y el tiempo, y está determinada por una serie de factores como las ecuaciones de conservación de masa y movimiento, la viscosidad, las fuerzas externas, la estratificación y la turbulencia.

Para describir completamente la dinámica del fluido se requiere de hasta nueve ecuaciones en derivadas parciales. No obstante, distintos autores, como Müller [cite:@muller2003particle] Liu [cite:@Liu-Liu03] o Perea et al. [cite:@PerCor12] sugieren la pertinencia de prescindir de un gran número de ellas, y centrarse en la ecuación obtenida a partir de la conservación del momento. Es por ello, que se utiliza la denominada ecuación de Navier--Stokes ([[ec:Navier--Stokes]]) que en su formulación lagrangiana se puede expresar como sigue:
#
#+NAME: ec:Navier--Stokes
\begin{gather}
\rho\frac{\mathrm {D} v}{\mathrm {D} t} = -\nabla P + \nu\nabla^2 v + \rho g
\end{gather}
#
@@latex:\noindent@@ donde
$\rho$ es la densidad del fluido, $\frac{\mathrm {D}}{\mathrm {D} t}$ es la derivada sustancial, $v$ es la velocidad del flujo del fluido, $P$ es la presión del fluido, $g$ es la gravedad y $\nu$ es la viscosidad del fluido.

Esta ecuación expresa el comportamiento del fluido y su dinámica, describiendo cómo la velocidad, la presión y la densidad evolucionan en el tiempo y en el espacio.

Aunque es indudable las ventajas que representa poder operar exclusivamente con la ecuación de Navier--Stokes en la simulación de fluidos, algunos autores como  han apuntado que precisamente en la simulación de fluidos, es conveniente incorporar la propiedad de /incompresibilidad/, sobre todo en el ámbito de la CG, ya que esta no está considerada en la ecuación de Navier--Stokes. Ha habido distintas propuestas técnicas como las de Solenthaler [cite:@Solenthaler-Pajarola09] y Teschner [cite:@BecTes07] que pretenden resolver el problema /imponiendo/ la incompresibilidad mediante procesos de adaptación de resultados calculando el valor instantáneo de la presión o a través de la composición de la ecuación de Navier--Stokes y la conservación de la masa. Debido a estas desventajas, en este proyecto consideraremos un modelo basado en la propuesta de Perea et al. [cite:@Perea-Cordero16] que impone implícitamente la incompresibilidad.

** Diferentes métodos numéricos

Simular un fluido implica resolver las complejas ecuaciones en derivadas parciales con las que se describe, cuantitativamente, el flujo del fluido. Para llevar a cabo esta tarea, es necesario utilizar métodos numéricos que transformen esas complejas ecuaciones diferenciales en un conjunto de ecuaciones algebraicas, relativamente más sencillas de manejar.

Existen varios métodos numéricos que se han desarrollado para la simulación de fluidos, y se pueden clasificar según su tipología en dos grupos principales:

- *Métodos Eulerianos*

  Se trata de métodos en los que se considera el fluido como un medio continuo (mallas, generalmente de triángulos o cuadriláteros, en el caso de bi–dimensional o bien, hexaedros o tetraedros, para el caso tridimensional) y se describen las variables en un punto fijo del espacio y el tiempo. Entre estos métodos se encuentran el método de volúmenes finitos o FEM (del inglés /Finite Element Method/) y el método de diferencias finitas o FDM (del inglés /Finite Difference Method/). Ambos métodos se basan en la discretización del espacio y del tiempo y se utilizan para resolver ecuaciones diferenciales. Son ampliamente utilizados para simular el comportamiento de fluidos incompresibles y compresibles, especialmente en casos donde hay un gran número de obstáculos o geometrías complejas. Sin embargo, presentan importantes desventajas ya que las ecuaciones que se obtiene están fuertemente ligadas, no se obtienen unos resultados precisos para simulaciones tridimensionales y requiere un gran coste computacional y de requisitos computacionales. Por eso en el ámbito de CG, no suele utilizarse este tipo de metodologías.

- *Métodos Lagrangianos*:

  Son aquellos métodos en los que se considera el fluido como un conjunto de partículas y se describen las variables en función de la posición y la velocidad de cada partícula. El método de partículas (SPH) es un ejemplo de estos métodos, se basa en la resolución de la ecuación de continuidad y la ecuación de movimiento para cada partícula, utilizando una función de suavizado o kernel para la interpolación entre las partículas. Este método es ampliamente utilizado en aplicaciones como la simulación de fluidos en medios porosos, fluidos multi-componentes y en problemas de dinámica de fluidos complejos.

  Los métodos lagrangianos presentan indudables ventajas frente a los eulerianos, ya que, por una parte, al operar con partículas en lugar de mallas permite una mayor simplificación de los cálculos y permite una gran adaptabilidad al contenedor del fluido, especialmente cuando se simulan líquidos. Por otro lado, resolver la ecuación de Navier--Stoke mediante el uso de técnicas lagrangianas, “genera” un conjunto de ecuaciones desacopladas que facilita el proceso de solución. Otra importante característica de los métodos lagrangianos  es que facilitan simular la interfase entre fluidos –por ejemplo aire–líquido– y la conservación de la masa.

El SPH (/Smoothed Particle Hydrodynamics/) se presenta como el método más destacable de los métodos lagrangianos. Se trata método numérico utilizado para simular el comportamiento de fluidos. En este método, el fluido se representa como un conjunto de partículas que se mueven e interactúan entre sí a través de fuerzas de interacción, definido a partir de las ecuaciones en derivadas parciales con las que se describe el flujo del fluido. Cada partícula tiene una masa y está sujeta a la influencia de las demás partículas, las más próximas, a su alrededor. Esta interacción local es la que modela la interacción y permite reproducir el comportamiento de los fluidos de manera realista. Dado los buenos resultados que ofrece, el método SPH se utiliza a menudo en aplicaciones de simulación de fluidos en la industria del cine y en la ingeniería, así como en la investigación científica.

Algunas de las ventajas específicas asociadas al uso del método SPH son las siguientes:

- Simplicidad de implementación: SPH es relativamente fácil de implementar y requiere poca información previa sobre el sistema que se está simulando.

- Flexibilidad: SPH es un método muy flexible que se puede utilizar en una amplia variedad de aplicaciones y escenarios.

- Capacidad de manejar flujos no newtonianos: SPH es capaz de manejar flujos no newtonianos, lo que lo hace adecuado para la simulación de fluidos con comportamientos no lineales.

- Robustez: SPH es un método robusto que puede manejar cambios bruscos en el flujo y en la topología del sistema.

- Facilidad de paralelización: SPH es fácil de paralelizar lo que permite acelerar la simulación en máquinas con varios núcleos o en /clusters/ de computación.

A pesar de estas ventajas, el método SPH tiene algunos problemas asociados que hace que aún sea un campo de investigación en desarrollo. Algunas de las desventajas que este método presenta son:

- Dificultad para manejar obstáculos sólidos: uno de los principales problemas de SPH es la dificultad para manejar obstáculos sólidos de manera efectiva. Esto puede dar lugar a penetraciones de partículas a través de los obstáculos lo que afecta al realismo de la simulación.

- Pérdida de precisión en la modelización de ondas: SPH tiende a tener dificultades para reproducir ondas de alta frecuencia y amplitud, lo que puede afectar la precisión de la simulación en algunos casos. El resultado es la aparición de atenuación de este tipo de ondas lo que induce sobre-amortiguamiento poco realista.

- Sensibilidad a los parámetros de entrada: el rendimiento de SPH puede ser sensible a los parámetros de entrada, lo que puede hacer difícil encontrar los valores óptimos para una simulación determinada.

** Objetivos

El principal objetivo de este trabajo es desarrollar un simulador tridimensional que sea capaz de simular el comportamiento de un fluido de manera realista y conseguir alcanzar el máximo rendimiento posible utilizando el lenguaje de programación CUDA que permite programar en las GPUs de NVIDIA de manera relativamente sencilla y paralelizar los cálculos de SPH, tales como la búsqueda de partículas vecinas y la actualización de sus posiciones y velocidades, consiguiendo una mayor velocidad en la obtención de estos resultados.

En el desarrollo del proyecto también se ha investigado en solventar los principales inconvenientes que tiene el método SPH, en analizar los diferentes parámetros dentro de la simulación para que la simulación sea estable y estudiar otras propuestas, en desarrollar una implementación que nos permita colisionar de manera realista con diferentes tipos de sólidos rígidos y en implementar exportadores para motores de renderizado para que el proyecto tenga un renderizado de mayor calidad

El proyecto deberá tener una estructura que sea escalable ya que no se pretende que este proyecto, dado lo ambicioso de sus objetivos, no es finalizar dentro del tiempo dado durante el TFG si no que se desarrolle más allá del ámbito de la universidad.

** Organización del proyecto

El presente documento se divide en ocho capítulos, en los cuales se explica el contenido de la investigación, la experimentación realizada, así como los resultados obtenidos durante su desarrollo:

En el capítulo [[*Análisis]] se describirá de manera técnica el proyecto a desarrollar y se enumerarán los requisitos que debe cumplir el trabajo y las herramientas utilizadas en el proceso de desarrollo.

En el capítulo [[*Fundamentos del Método SPH]] se revisara en profundidad el método SPH, especialmente en sus fundamentos matemáticos, los diferentes estudios que avalan el método y los problemas del mismo junto con las diferentes soluciones creadas para solventarlos.

En el capítulo [[*Búsqueda de partículas vecinas]]

En el capítulo [[*Método de integración temporal]] se explican los diferentes métodos de integración temporal, uno de los pilares en la simulación, qué papel juega dentro de nuestra simulación y se explica la decisión de escoger un método sobre otro.

En el capítulo [[*Colisiones]] se discute brevemente una de las dificultades del método SPH: la reacción ante obstáculos, y como se ha resuelto la problemática desarrollando un gestor de colisiones.

En el capítulo [[*Características de las herramientas de implementación del proyecto]] se detallan las características del lenguaje CUDA, indicando los motivos de su elección y las ventajas e inconvenientes que presenta. También se explica brevemente la librería gráfica OpenGL. Esta librería se utilizó en un principio para visualizar el comportamiento de la simulación de manera gráfica, aunque posteriormente se ha cambiado por un /exportador,/ que directamente exporta los datos de las partículas para un renderizado en un programa comercial.

En el capítulo [[*Estructura del simulador y resultados]] se lleva a cabo la descripción de cómo se ha implantado todo lo explicado anteriormente y la estructura del simulador. Además se presentan los resultados obtenidos.

Finalmente, en el capítulo [[*Conclusiones y trabajo futuro]] se muestran las conclusiones obtenidas a partir de los resultados y se exponen las diferentes ampliaciones y posibilidades que tiene este proyecto en el futuro.

* Análisis

En este segundo capítulo explicaremos todo lo concerniente al estudio previo desarrollado para el simulador solicitado. Se describirá de manera técnica, se enumerarán los requisitos que se deben cumplir en la aplicación, los objetivos durante la duración del proyecto y las herramientas necesarias.

** Definición del problema real

Se solicita el desarrollo de un simulador que dé como resultado simulaciones de fluidos, con un comportamiento realista y que sea versátil, entendiendo un comportamiento realista como aquel que bajo las mismas condiciones que un evento real se comporta de manera similar al mismo. Con versátil que se pueden modificar las variables del entorno sin que afecte a la precisión de la simulación. Además de intentar aumentar el rendimiento de este.

** Problema Técnico – Product Design Specification (PDS)

Aunque este proyecto de TFG sigue el desarrollo de un simulador y no es una aplicación software al uso, se va a utilizar la metodología PDS para explicar de una manera técnica, desde la perspectiva de un desarrollador, la estructura que sigue el simulador a desarrollar.

** Funcionamiento

El funcionamiento del simulador será tal que a partir de unos parámetros de entrada a modificar en el código, este será capaz de ejecutar un numero de instrucciones determinadas que darán como resultado un programa, que tras su compilación y ejecución, exportara un numero determinado de archivos binarios que sirven para describir el comportamiento de la simulación. Estos después podrán ser utilizados en un motor de renderizado que nos facilite la visualización de la simulación.

** Entorno

- *Entorno Software*: Para el desarrollo del simulador es necesario un compilador de C/C++ y el software de CUDA (SDK y Toolkit) obtenido a través de la página web de NVIDIA y un entorno de desarrollo integrado o IDE. Debido a que el IDE (Integrated Development Environment) desarrollado por Microsoft, Microsoft Visual Studio 2019, trae integraciones para estas dos piezas de software además de que el SDK de CUDA proporciona proyectos ya configurados en Microsoft Visual Studio, se ha decidido desarrollar el simulador en este IDE y no en otro.

- *Entorno Hardware*: Debido a que el simulador utiliza la librería CUDA que solo funciona con tarjetas desarrolladas por NVIDIA, para la ejecución y desarrollo de nuestro simulador es necesario una tarjeta NVDIA, además debido a que muchas tarjetas de NVIDIA muestran algunos problemas de incompatibilidad en entornos Linux y que hemos decidido utilizar el IDE Microsoft Visual Studio 2019, es necesario contar con un equipo (portátil u ordenador de sobremesa) que opere bajo un sistema operativo Windows.

- *Entorno de Usuario*: El desarrollo de este simulador esta orientado a profesionales científicos e investigadores del campo de las Computer Graphics, para resaltar las posibles mejoras que el uso de la programación paralela en GPUs puede acelerar programas altamente costosos como puede ser una simulación de fluidos basada en física. Aun así los resultados obtenidos del simulador al pertenecer al ámbito de las Computer Graphics y ser altamente visuales pueden ser apreciados por cualquier persona.

** Vida Esperada

Al enmarcarse en un proyecto de investigación es extremadamente complejo especificar la vida esperada del simulador. El desarrollo de este simulador se basa en diferentes estudios ya propuestos como se explica en el capitulo 1, con el objetivo de tener una mejora de rendimiento utilizando la potencia de calculo que ofrecen de las GPU. Por tanto, se espera que este simulador sirva como punto de partida hacia mejoras en el rendimiento de la simulación de fluidos basada en física y que tenga una duración prolongada, además de que se siga ampliando una vez acabado el ámbito de este TFG con los nuevos estudios y hardware futuros.

También al ser CUDA una plataforma desarrollada por NVIDA una de las mayores empresas productoras de tarjetas gráficas en el mundo, esta ofrece un soporte continuo a sus librerías y debido al éxito y potencial que ha demostrado el uso de esta, se puede suponer que CUDA no se dejara de mantener en el corto plazo.

** Ciclo de mantenimiento

Al depender el desarrollo de este simulador en gran medida de la evolución del lenguaje CUDA C, éste tendrá que ser revisado frente a posibles mejoras que se implementen en las nuevas versiones desarrolladas por NVIDIA. Además se deberán tener en cuenta las nuevas publicaciones científicas que puedan resultar en un mejor rendimiento del simulador. Aunque sin esto el simulador seguirá siendo funcional, no estará al día con los nuevos avances y su mejora de rendimiento, por lo que uno de los principales objetivos de este proyecto puede quedar en algo superficial.

** Competencia

Al tratarse del desarrollo de un simulador, podemos considerar como competencia a los diversos estudios presentados cada año en eventos comunitarios que desarrollan grupos de interés en la computación gráfica como SIGGRAPH o Eurographics en los que se presentan los avances realizados cada año en este ámbito por diferentes grupos de investigación y desarrolladores de Software.

** Aspecto Externo

El simulador junto con los resultados obtenidos de este y su aspecto renderizado serán entregados al tutor Juan José Perea Rodríguez, junto con esta memoria que explica la metodología elegida y la estructura del simulador.

** Estandarización

El lenguaje escogido, CUDA C, permite una estandarización, ya que al ser C un lenguaje multiplataforma se podría ejecutar en cualquier sistema operativo, siempre que el equipo  contara con una tarjeta NVIDA. Además, se ha realizado una exportación de resultados a archivos binarios que permiten renderizar la imagen en multitud de herramientas de renderizado, lo que resulta en una portabilidad para la visualización de la simulación aún mayor.

** Calidad y Fiabilidad

Al tratarse el desarrollo de este simulador un TFG el encargado principal del desarrollo de esta herramienta es el alumno Antonio Moreno Talero, siendo supervisado por el tutor académico Juan José Perea Rodríguez para controlar el correcto desarrollo del proyecto. También Juan José Perea Rodríguez al ser un experto en el ámbito de la computación gráfica y la simulación basada en fluidos se encargará de supervisar el proyecto para que cumpla con los fundamentos matemáticos que conlleva una simulación física basada en física.

** Programa de Tareas

El desarrollo del simulador será llevado a cabo en diferentes partes:

1. Primero se realizará un análisis y estudio previo de diferentes metodologías de simulación de fluidos junto con maneras de mejorar el rendimiento de este, con el objetivo de comprender las posibles alternativas existentes en el desarrollo de un simulador de fluidos y que ventajas e inconvenientes presenta cada uno.

2. Una vez elegida la metodología a seguir en el desarrollo de la simulación, se planteará una estructura escalable y funcional que sea programable para su posterior desarrollo a la vez que se estudian las herramientas necesarias para llevar a cabo esta implementación.

3. Por último, tras alcanzar una comprensión suficiente de las herramientas a utilizar se llevará a cabo su implementación en el lenguaje escogido, la programación de la estructura del simulador.

** Pruebas

Al tratarse de una simulación se espera que tenga un comportamiento realista y versátil, y que en ningún momento de la simulación presente comportamientos anómalos, como dispersión de partículas o turbulencias que no tuvieran que relación con el comportamiento a simular. Para ello se ha seguido un desarrollo escalado en el que se ha ido probando y ejecutando diferentes partes del proceso, conforme se iba desarrollando, testeando en vivo cada vez que se añadía una nueva funcionalidad y corrigiendo los errores cometidos.

** Seguridad

El proyecto al ser un simulador no guarda ninguna información privada o importante del usuario por lo que no es necesario implementar ninguna medida de seguridad externa a este.

** Análisis de requisitos

En este apartado se realizará un análisis de requisitos que debe satisfacer el desarrollo del simulador para ser considerado aceptable.

*** Requisitos Generales
A continuación se definen los objetivos a alto nivel:

- RG-01: El simulador debe producir resultados realistas.
- RG-02: El simulador debe ser versátil.
- RG-03: El simulador debe reducir al máximo el coste computacional.

*** Requisitos de información

A continuación se presentan los requisitos de información, que presentan la información relevante que es necesaria para un simulador de fluidos

- RI-01: El usuario debe indicar el numero de partículas a utilizar durante la simulación
- RI-02: Las partículas del simulador deben almacenar sus propiedades constitutivas

*** Requisitos Funcionales

Los mínimos que debe alcanzar el simulador vienen dados por los siguientes requisitos funcionales

- RF-01: El simulador debe ser capaz de colisionar con sólidos rígidos
- RF-02: El simulador debe ejecutar parte del código en paralelo
- RF-03: Se debe poder añadir diferentes sólidos rígidos dentro del simulador
- RF-04: Las partículas deben modificar sus posición y velocidad dentro del simulador
- RF-05: El simulador debe implementar algún algoritmo de búsqueda de vecinas.

*** Requisitos No Funcionales

A continuación, con los requisitos no funcionales se determinan ciertas restricciones que debe cumplir nuestro simulador

- RNF-01: El simulador debe exportar binarios para su posterior renderizado
- RNF-02: El simulador debe trabajar sobre una tarjeta NVIDIA
- RNF-03: El simulador debe trabajar bajo la metodología SPH

*** Matriz de Trazabilidad de Requisitos

Después de haber especificado todos los requisitos necesarios para la simulación, se debe garantizar que estos van a cumplir los objetivos establecidos. Una herramienta gráfica muy útil para esto es la elaboración de matrices de trazabilidad. Una matriz de trazabilidad es una tabla en la que se relacionan todos los requisitos planteados con los objetivos (requisitos generales) establecidos y sirve para visualizar qué resultado alcanzará cada requisito. Las siguientes tablas muestran las matrices de trazabilidad de los requisitos generales respecto a los requisitos de información, requisitos funcionales y requisitos no funcionales respectivamente.

#+CAPTION: Matriz de trazabilidad de los requisitos generales respecto a los requisitos de información \\
#+ATTR_LATEX: :align |c|c|c|c|
| RI \ RG | RG-01 | RG-02 | RG-03 |
|---------+-------+-------+-------|
| RI-01   | -     | X     | -     |
| RI-02   | X     | X     | -     |

#+CAPTION: Matriz de trazabilidad de los requisitos generales respecto a los requisitos funcionales \\
#+ATTR_LATEX: :align |c|c|c|c|
| RF \ RG | RG-01 | RG-02 | RG-03 |
|---------+-------+-------+-------|
| RF-01   | X     | X     | -     |
| RF-02   | -     | -     | X     |
| RF-03   | X     | X     | -     |
| RF-04   | X     | -     | -     |
| RF-05   | -     | -     | X     |

#+CAPTION:Matriz de trazabilidad de los requisitos generales respecto a los requisitos no funcionales \\
#+ATTR_LATEX: :align |c|c|c|c|
| RNF \ RG | RG-01 | RG-02 | RG-03 |
|----------+-------+-------+-------|
| RNF-01   | X     | -     | -     |
| RNF-02   | -     | -     | X     |
| RNF-03   | X     | X     | X     |

* Fundamentos del Método SPH
** Introducción

En la introducción de esta memoria de TFG, describimos las características generales de las magnitudes dinámicas y constitutivas del fluido. También expusimos las complejidades que tiene resolver de la ecuación dinámica del fluido, la ecuación [[ec:Navier--Stokes]], y la imposibilidad de resolverla, en la mayoría de los casos, mediante técnicas analíticas. La consecuencia de esta limitación es la necesidad del uso de técnicas numéricas. Así mismo, esbozamos la metodología lagrangiana que utilizamos en este proyecto para simular el flujo del fluido, concretamente, el método Smoothed Particles Hydrodynamics (SPH).

En este capítulo vamos a concretar las características generales y los fundamentos en los que se basa SPH. Además, describiremos los problemas de estabilidad que pueden presentar los resultados obtenidos mediante SPH. Problemas que hemos considerado para evitarlos y obtener simulaciones realistas en diferentes entorno de simulación.

Si bien el método SPH fue desarrollado por Gingold--Monaghan [cite:@Gingold-Monaghan77] y Lucy [cite:@Lucy77], para la simulación de sistemas de múltiples cuerpos, como ocurre en cosmología, rápidamente fue adaptado para simular las ecuaciones dinámicas asociadas a medios continuos.  Específicamente, la formulación desarrollada por Gingold--Monaghan [cite:@Gingold-Monaghan77], es la que se utilizó para modelar las ecuaciones en derivadas parciales del fluido.

Para poder aplicar el método SPH en la simulación del flujo del fluido, es necesario que el continuo que es el fluido, quede representado, unívocamente, por un sistema de partículas que puedan interactuar entre cada una de ellas. Así pues, para una correcta representación del fluido mediante partículas, se tiene que cumplir que la suma de la masa de todas las partículas sea igual a la masa de la totalidad del fluido. Así queda satisfecha una de las restricciones más importantes en física que es \textit{la conservación de la masa}.  Una vez que el fluido es transformado en un sistema de partículas, se tiene que \textit{modelar} la interacción entre las partículas. Aquí es donde entra en juego la formulación de SPH, que describiremos a lo largo de este capítulo, con las que se modela las ecuaciones en derivadas parciales del fluido. Resumidamente, las dos \textit{piedras angulares} de SPH son:

1. /Las partículas/ donde se particularizan las magnitudes del fluido ($\rho$,$\nu$...), la masa y las magnitudes dinámicas (posición, velocidad, aceleración).

2. /La función para modelar la interacción/, que en el ámbito de SPH, suele denominarse /función kernel/. Esta función debe satisfacer ciertas condiciones, que describiremos posteriormente en este mismo capítulo, entre las que destaca la continuidad, su dependencia de la distancia y que esta dependencia es de monótona decreciente con la distancia, tal como se indica en [cite:@Liu-Liu03].

Visualmente, lo que acabamos de describir se ilustra en la figura \ref{fig:esquemaKernel}

#+CAPTION: Ilustración de los pilares en los que se asienta el método SPH: partículas y función kernel. La interacción está restringida por el dominio de la función, cuyo radio es $h$. Las partículas que cumplan que su distancia es inferior a $h$, se denominan partículas vecinas.
#+ATTR_LATEX: :width 10cm
[[./graficos/kernel.pdf]]


Una vez que hemos descrito brevemente los pilares fundamentales del método SPH, seguidamente vamos a llevar a cabo una descripción más precisa. En la sección [[*Fundamentos del Método SPH]] vamos a llevar a cabo la definición de las características generales, enunciadas por Monaghan et al. [cite:@Gingold-Monaghan77] y Lucy [cite:@Lucy77] en sus primeras propuestas, y ampliada a lo largo de las últimas décadas. A continuación, se establecerán las formulaciones matemáticas con las que se modelan las ecuaciones del fluido. Para finalizar el capítulo se establecerán las principales limitaciones que presenta SPH y que son consideradas a la hora de implementar la simulación del fluido planificada en este proyecto.

** Descripción del Método SPH

El método SPH, según se ha explicado en la sección [[*Introducción]], tiene dos pilares fundamentales, estos son: las partículas y las funciones kernel. Sobre cada una de las partículas, con las que se modela el fluido en para utilizar SPH, se definen cada una de las magnitudes necesarias para resolver la ecuación NS --ecuación [[ec:Navier--Stokes]]--, es decir, la velocidad, la presión, la densidad y la masa. Además, sobre cada una de las partículas se define una función kernel que ``\textit{pondera}'' cada una de esas magnitudes dinámicas, a partir del valor que tienen dichas magnitudes en sus partículas más próximas. Modelar un fluido mediante partículas que no está ligadas a través a una malla implica que el movimiento de las partículas sea el flujo del fluido. Debido a este hecho, se puede afirmar que SPH es un método lagrangiano.

Desde un punto de vista numérico, cuando el fluido es modelado mediante partículas, y sus magnitudes se aproximan mediante SPH, la ecuación de NS se transforma en un conjunto de ecuaciones algebraicas que no están acopladas entre sí. Este desacoplamiento es gracias a la formulación de la función kernel. Según se afirma en Liu et al. [cite:@Liu-Liu03], esta formulación reduce el coste computacional y simplifica los cálculos si se compara con el modelado basado en mallas. No obstante, Price [cite:@Price12] advierte de que el número de partículas vecinas $j$, de cada una de las partículas $i$, debe ser relativamente alto, en un rango mínimo de $80-120$. Sin embargo, dependiendo del tipo de función kernel, y más concretamente de su formulación, este rango de valores puede disminuir, tal como se indica en [cite:@Price12; @Perea-Cordero16]. Así pues, se puede afirmar que las características analíticas condiciona la calidad de la simulación.

Existe un consenso en relacionar las características analíticas de las diferentes funciones kernel, con la estabilidad y el realismo. A este respecto, se han llevado a cabo una gran cantidad de estudios que establecen cuales deben ser las características esenciales, que una función monótona decreciente, debe satisfacer para obtener simulaciones de fluido realistas. La primera función kernel fue propuesta por Monaghan et al. [cite:@Gingold-Monaghan77; @Monaghan92] y se trata de la función exponencial. Esta función puede proporcionar resultados adecuados, pero presenta una incompatibilidad, que es el hecho de que su radio de dominio soportado $h$ es infinito y dado este valor establece el número de partículas vecinas, se tendría un alto número, lo cual dificulta el cálculo de las magnitudes dinámicas del fluido, como es destacado en [cite:@Liu-Liu03].

Además de la limitación destacada por Liu et al. [cite:@Liu-Liu03], se han desarrollado diversos estudios que establecen las características que hacen a cualquier función monótona decreciente una ``\textit{buena}'' función kernel. Estos estudios son:


1. Fulk et al. [cite:@Fulk94] establece que el dominio de definición de la función kernel debe ser cerrado y acotado y además su decrecimiento debe ser suave.

2. Otro estudio muy destacado es el llevado a cabo por Cappuzzo et al. [cite:@Capuzzo-DiLisio00] en el que se afirma que la función kernel debe ser una función positiva que induzca también un valor positivo de la densidad de masa.

3. \label{punto:punto2} Dehnen et al. [cite:@Dehnen-Aly12] centra su estudio no sólo en la función kernel, sino también en las características que debe presentar la primera derivada de la función kernel. Según Dehnen  la función kernel debe ser una función par y su gradiente, con el que se obtiene la fuerza de presión en la ecuación [[ec:Navier--Stokes]], debe tener un valor nulo en el origen, es decir, en la posición de la partícula.

4. De las investigaciones desarrolladas por Cabezón [cite:@CabGarRel08], Price [cite:@Price12] y Dehnen et al. [cite:@Dehnen-Aly12], se deduce que la mejor función kernel debería ser continua e infinitamente diferenciable, lo que el matemática analítica se denomina $\mathcal{C}^{\infty}$.

Otras características que tiene el método SPH, que representan una ventaja cualitativa a lo hora de llevar a cabo la simulación son:

1. \emph{La conservación de la masa} que es posible porque la masa de cada partícula  $m_{p_{i}}$, representa una fracción de la masa total del fluido, es decir $\sum_i m_{p_{i}} = M_f$, donde $M_f$ representa la masa total del fluido. La principal ventaja es que considerando exclusivamente la ecuación de NS es posible simular el fluido, tal como se desataca en [cite:@Monaghan92; @Liu-Liu03].

2. \emph{Permite definir el límite liquido--aire}, conocida también como superficie libre, en el ámbito de CG [cite:@MulChaGro03] es consecuencia del modelado a través de partículas. Esta característica representa una clara ventaja frente a los modelos basados en mallas, como destaca [cite:@AkiIhmAkin.etal12].

3. \emph{No requiere de la implementación del término de advección.} Por tratarse SPH de una técnica lagrangiana, y el hecho de que las partículas se desplazan con el flujo del fluido, no se debe considerar el término de advección, según se explica en [cite:@Liu-Liu03].

4. \emph{La ecuación de NS se transforma en un conjunto de ecuaciones algebraicas desacopladas.} Comparativamente con los métodos basados en mallas esto representa una ventaja ya que no hay que resolver complejos sistemas de ecuaciones a la hora de implementar la simulación del fluido mediante SPH [cite:@Liu-Liu03]. Esta ventaja es muy importante si se desea paralelizar el cálculo de la dinámica del fluido.

5. \emph{Simplifica las colisiones del fluido con el contorno}, como describiremos en el capítulo [[*Colisiones]] de esta memoria de proyecto. Se debe a que es más fácil calcular la colisión partícula contorno del cuerpo rígido que la colisión entre diferentes mallas, tal como se indica en [cite:@MulChaGro03].

No obstante, aunque SPH presenta las ventajas que acabamos de describir, puede generar inestabilidades en las simulaciones que afecten a su realismo. Esta limitación se hace muy visible cuando la cantidad de partículas vecinas es baja, entorno a $20$, tal como destaca Yan et al. [cite:@YanPenLiu14]. La complejidad de diseñar una función kernel que evite este problema es una tarea compleja que sale fuera de los objetivos de este proyecto. En este proyecto utilizaremos la propuesta de Perea et al. [cite:@Perea-Cordero16; @Perea-Cordero18] donde se desarrolla un estudio de estabilidad y precisión en simulaciones de fluido mediante SPH y formulan una función kernel que garantiza buenos resultados aunque el número de partículas vecinas sea bajo.

Tras esta breve introducción al método SPH, el resto del capítulo de organiza del siguiente modo. En la sección [[*Fundamentos del Método SPH]] vamos a llevar a cabo una descripción de los fundamentos de SPH, tal como las definió Monaghan et al. [cite:@Gingold-Monaghan77] y Lucy [cite:@Lucy77]. Seguidamente, en la sección [[*Fundamentos de SPH y su Formulación]] expondremos cómo quedan las ecuaciones dinámicas del fluido modeladas mediante la formulación SPH. Así mismo, expondremos como se obtienen las ecuaciones discretas, que utilizaremos en nuestro simulador, y como éstas se obtienen a partir de la formulación integral, que es el punto de partida que desarrolló Monaghan et al. [cite:@Gingold-Monaghan77]. El proceso seguido en la descripción es el propuesto por Monaghan [cite:@Monaghan82; @monaghan1992smoothed], Liu [cite:@Liu-Liu03] y Price [cite:@Price12].

** Fundamentos de SPH y su Formulación

Desde la perspectiva de análisis funcional, tal como se describe en [cite:@Liu-Liu03], el método SPH se sitúa dentro de la denominada convolución funcional. Expresándola en otros términos, la convolución permite que cualquier función desconocida pueda calcularse a partir de la combinación de funciones conocidas (que en el ámbito de SPH son las ya mencionadas funciones kernel). A pesar de que este es el fundamento que permite operar con funciones conocidas, para obtener la solución desconocida de las ecuaciones en derivadas parciales que describen la dinámica del fluido, el origen del método SPH, tal como lo establecieron Monaghan [cite:@Gingold-Monaghan77] y Lucy [cite:@Lucy77], difiere en parte. El punto de partida es desarrollar una formulación integral de una función incógnita, para posteriormente formular su expresión discreta, que será la utilizada en el sistema de partículas que modela el fluido a simular. Según esta ``visión'', Monaghan estableció que la formulación integral de cualquier función incógnita, se puede obtener siguiendo el mismo criterio establecido por Dirac para formular la denominada función $\delta$ de Dirac.

Existe un consenso en descomponer, en dos etapas, las operaciones con las que Monaghan [cite:@Gingold-Monaghan77] establece la ecuación fundamental de SPH acorde con el criterio establecido por Dirac para formular su función $\delta$:

1. \label{punto:paso1Cap2FormIntegral} La primera etapa se basa en considerar, tal como estableció Dirac, la formulación integral de la función  $\delta$, pero considerando que se trata, en lugar de una pulsiana, de una función cerrada y acotada, lo que el análisis de funciones se conoce como \textit{función compacta}, con un dominio espacial mayor que el de $\delta$. Llegados este punto, merece la pena destacar que esa función compacta, con la que se ``sustituye'' a $\delta$, es la función kernel de SPH, que será descrita con mayor profundidad en la sección [[*Fundamentos del Método SPH]]. De este modo, Monaghan establece la formulación integral del método SPH.

2. \label{punto:paso2Cap2FormDiscreta} En la segunda etapa se opera sobre la formulación integral desarrollada en la primera etapa, para transformarla en una expresión discreta, esto es, transformar la integral en sumatoria. De este modo, las ecuaciones obtenidas pueden ser aplicadas sobre un sistema discreto como, por ejemplo, es el sistema de partículas con el que se modela el fluido a simular. Por ello, son estas ecuaciones discretas las que utilizaremos en nuestro simulador.

En las próximas subsecciones [[*Formulación integral de las ecuaciones del método SPH]] y [[*Formulación discreta de las ecuaciones del método SPH]] llevaremos a cabo una descripción más exhaustiva de las dos etapas que, brevemente, acabamos de describir. En dichas secciones vamos a seguir las líneas establecidas por [cite:@AkiIhmAkin.etal12; @monaghan1992smoothed].

*** Formulación integral de las ecuaciones del método SPH

Esta sección se corresponde con la primera etapa, es decir, con la etapa \ref{punto:paso1Cap2FormIntegral}. Según formuló Monaghan [cite:@Gingold-Monaghan77], a partir de la función $\delta$ de Dirac, cualquier función desconocida  $f$ la expresa en términos de \ref{ec:deltaDirac}:

\begin{equation}\label{ec:deltaDirac}
f(r)=\int f(r')\delta(r-r')dr',
\end{equation}

@@latex:\noindent@@ donde $f$ hace referencia a la función desconocida, $r$ es a la posición, $r'$ es la posición de cualquier punto dentro del dominio de definición de $f$ y $\delta$ es la función de Dirac.

El siguiente paso seguido por Monaghan [cite:@monaghan1992smoothed; @Gingold-Monaghan77] es sustituir la función $\delta$ por una función con extensión espacial. Haciendo ese se obtiene la ecuación fundamental del método SPH. La expresión obtenida es \ref{ec:kernelIntegral}.

\begin{equation}\label{ec:kernelIntegral}
\tilde{f}(r)=\int_{\Omega} f(r')W(r-r',h)dr'
\end{equation}

donde  $(\;\tilde{}\;)$ se utiliza para indicar que $\tilde{f}(r)$ es el valor aproximado de $f(r)$, $W$ es la función con extensión espacial que sustituye a la función $\delta$, la que en SPH se denomina \textit{función kernel}, $\Omega$ es el volumen de definición de $W$ y $h$ es el radio  de dicho dominio de definición, que en el ámbito de SPH se conoce como \textit{radio del dominio soportado}.

Puede deducirse que  la función $W$ de la ecuación \ref{ec:kernelIntegral}, la función kernel, es fundamental en SPH. ``\textit{A priori}'' cabría esperar que cualquier función compacta podría jugar el papel de función kernel, sin embargo, existe un conjunto de características, las cuales serán descritas posteriormente, que la función debe cumplir. Monaghan [cite:@Monaghan92], establece que, al menos, la función kernel debe satisfacer los siguientes criterios:

1. \label{punto:SPH_1} Cualquier función $W$ candidata a ser función kernel, debe estar normalizada y cuando el radio del dominio soportado $h$ tienda a cero, $W$ debe ser una función pulsiana como es la $\delta$ de Dirac, es decir:

   \begin{equation}\label{ec:condNormalizacion}
   \int_\Omega W dr' = 1
   \;\;\;\;\mbox{y}\;\;\;\;\lim_{h\rightarrow 0} W(r-r',h) = \delta(r-r').
   \end{equation}

2. \label{punto:SPH_3} $W$ tiene que ser compacta, es decir, debe ser una función serrada y acotada. Además, Monaghan sugiere que debe ser una función par, es decir, simétrica respecto del origen y decaer suavemente con la distancia.

Cabe destacar que la elección de la función kernel, es uno de los problemas recurrentes en el ámbito de SPH. Una buena elección, sobre todo cuando el número de partículas vecinas es relativamente bajo, garantiza resultados precisos y, por lo tanto, simulaciones realistas. Existen diferentes estudios en los que se analizan las características que debe cumplir una función compacta y simétrica para ser una buena función kernel. Merece destacar los estudios de Dehnen et al. [cite:@Dehnen-Aly12] y Yan et al. [cite:@YanPenLiu14] donde, además, hace una exposición de como controlar el error cometido. Sin embargo, realizar un estudio de las diferentes funciones kernel, queda fuera del ámbito de este capítulo, en el que describimos los fundamentos del método SPH.

*** Formulación integral de las derivadas de las ecuaciones de SPH

Una vez expuesta la formulación integral de SPH, el siguiente paso es ``adaptar'' esa formulación a la ecuación dinámica del fluido, es decir, la ecuación NS [[ec:Navier--Stokes]]. Por lo tanto, es necesario exponer la formulación del gradiente y el laplaciano, en términos de la ecuación \ref{ec:kernelIntegral}, ya que son las funciones que intervienen en la ecuación NS. Siguiendo los términos expuestos en [cite:@Liu-Liu03], se obtiene la ecuación \ref{ec:SPH11}:

\begin{equation}\label{ec:SPH11}
\nabla \cdot \tilde{f}(r)=\int_{\Omega}
\left[
\nabla\cdot f(r')
\right]W(r-r',h)dr',
\end{equation}

donde la expresión $\left[\nabla\cdot f(r')\right]$ se particulariza en $r'$ dentro del dominio soportado de $f$.

Para calcular el integrando de la ecuación \ref{ec:SPH11}, Monaghan [cite:@Monaghan92] hace uso de la regla de la cadena. Con esta operación la ecuación \ref{ec:SPH11} se transforma en la ecuación:

\begin{equation}\label{ec:SPH12}
\left[\nabla \cdot f(r')\right] W(r-r',h)=
\nabla\cdot\left[f(r') W(r-r',h)\right]-
f(r')\cdot \nabla\left[ W(r-r',h)\right],
\end{equation}

Sustituyendo la ecuación \ref{ec:SPH12} en \ref{ec:SPH11}, se obtiene la expresión del gradiente en términos de SPH, la ecuación que se obtiene es la expresión  \ref{ec:SPH13}:

\begin{equation}\label{ec:SPH13}
\nabla\cdot \tilde{f}(r)= \int_{\Omega}
\nabla\cdot\left[f(r')W(r-r',h)\right]dr'-
\int_{\Omega}
f(r')\cdot\nabla\left[W(r-r',h)\right]dr'.
\end{equation}

Tal como se indica en [cite:@Liu-Liu03], la ecuación \ref{ec:SPH13} es válida para calcular el gradiente de cualquier función. Sin embargo, para dotar de significado, se recomienda tener dos componente, una referida al volumen del dominio soportado y otro, específicamente, asociado al contorno. Expresándolo, en otros términos, en [cite:@Liu-Liu03], se recomienda que haya una componente de volumétrica y otra superficial (la asociada al contorno). Para que ello se cumpla, se hace uso del  \emph{Teorema de la Divergencia}, de este modo la ecuación \ref{ec:SPH13} se expresa en términos de la ecuación \ref{ec:SPH14}.

\begin{equation}\label{ec:SPH14}
\nabla\cdot \tilde{f}(r)= \int_{S}
f(r')W(r-r',h)\cdot \vec{n}dS-
\int_{\Omega}
f(r')\cdot\nabla\left[W(r-r',h)\right]dr'.
\end{equation}

donde $\vec{n}$ es el vector normal de la superficie que recubre el dominio $\Omega$.

La descomposición en dos componentes, una superficial y otra volumétrica, de la ecuación \ref{ec:SPH13} para obtener la ecuación \ref{ec:SPH14}, tiene un objetivo claro, tal como se indica en [cite:@Liu-Liu03], y es que si la función es compacta y el dominio soportado no ``penetra'' en los límites del fluido, por ejemplo en el contenedor en el que se encuentre confinado el fluido a simular, entonces la parte superficial de la ecuación \ref{ec:SPH14} se anula, por lo que se simplifica en términos de:

\begin{equation}\label{ec:SPH15}
\nabla\cdot \tilde{f}(r)=-\int_{\Omega}
f(r')\cdot\nabla\left[W(r-r',h)\right]dr'.
\end{equation}

# %Cabe destacar que si la condición de compacidad no es satisfecha entonces la %ecuación \ref{ec:SPH15} no es adecuada para obtener la aproximación $\nabla\cdot %\tilde{f}(r)$.

Siempre que se cumplan las condiciones para obtener la ecuación \ref{ec:SPH15}, se puede comprobar que el gradiente simplemente se obtiene como el producto de la función kernel por la función incógnita $f$, con lo que se simplifican los cálculos de las ecuaciones en derivadas parciales donde se utilicen, lo cual representa una ventaja operativa respecto de otras técnicas, como destaca Monaghan [cite:@Monaghan92].

En este proyecto vamos a utilizar funciones compactas, con lo que podemos utilizar las ecuaciones que se obtengan a partir de la expresión \ref{ec:SPH15}.


Para obtener ecuaciones diferenciales de orden superior, en Liu [cite:@Liu-Liu03], se propone extrapolar la ecuación \ref{ec:SPH15},para cualquier orden diferencial. Según su propuesta, la ecuación general que permitirá aproximar cualquier ecuación diferencial se expresa en términos de \ref{ec:SPHDerivadasGENERAL}:


\begin{equation}\label{ec:SPHDerivadasGENERAL}
\nabla ^l \tilde{f}(r)=-\int_{\Omega}
f(r')\cdot\nabla^l\left[W(r-r',h)\right]dr'.
\end{equation}

donde con $l$ se hace referencia al orden diferencial, p.e. $l=1$ será el gradiente y $l=2$ será el laplaciano.

*** Formulación discreta de las ecuaciones del método SPH

Mediante las ecuaciones \ref{ec:kernelIntegral}--\ref{ec:SPH15}, se tienen las expresiones con las que es posible transformar, analíticamente, las ecuaciones en derivadas parciales, con las que se describe el fluido, en términos del método SPH. Sin embargo, tal como se ha dicho previamente, estas ecuaciones no se pueden aplicar sobre un sistema discretizado, como es el sistema de partículas con el que se modela el fluido a simular. Para poder aplicar las expresiones \ref{ec:kernelIntegral}--\ref{ec:SPH15} a un sistema discreto, es necesario transformar dichas ecuaciones. Sucintamente, el proceso consiste en transformar las integrales, por sumatorias, restringidas a las partículas. En los estudios de [cite:@Price12; @Monaghan92], se describe el proceso clave que permite dicha trasformación y consiste en considerar que, cada una  de las partículas, representa una fracción del fluido, visto como un continuo, cuyo valor es  $\rho dV$. Teniendo en cuenta esta hipótesis es posible transformar la expresión \ref{ec:kernelIntegral} en la ecuación \ref{ec:spHAproximada}:

\begin{equation}\label{ec:spHAproximada}
 \tilde{f}(r_i) =\sum_{j\in\mathcal{N}(i)}\frac{m_j}{\rho_{j}}f(x_j) W(r_i-r_j,h),
\end{equation}

donde $\mathcal{N}(i)$ son las partículas vecinas de la partícula $i$, cuya cantidad viene condicionada por el valor del radio de dominio soportado, $h$.

Formulada la ecuación discreta con la que se aproxima la función $f$, el siguiente paso es formular las ecuaciones del gradiente. Siguiendo una línea de razonamiento análogo para obtener \ref{ec:spHAproximada}, Liu [cite:@Liu-Liu03] describe que la ecuación de partida es \ref{ec:gradientePre}.

\begin{equation}\label{ec:gradientePre}
\nabla \cdot \tilde{f}(r)=\int_{\Omega}
\left[
\nabla\cdot f(r')
\right]W(r-r',h)dr'=
\frac{\partial}{\partial r}\int \frac{f(r')}{\rho(r')}W(r-r',h)\rho(r')dr'
\end{equation}

A partir de la ecuación \ref{ec:gradientePre}, considerando que $f$ es compacta y no intersecta los límites del fluido, la ecuación \ref{ec:gradientePre} se reduce en términos de la ecuación \ref{ec:gradiente}:

\begin{equation}\label{ec:gradiente}
\nabla \tilde{f}(r)=\frac{\partial}{\partial r}\int \frac{f(r')}{\rho(r')}W(r-r',h)\rho(r')dr'\approx
\sum_{j\in\mathcal{N}(i)}m_j\frac{f_j}{\rho_j}\nabla W(r_j-r_i,h).
\end{equation}

Operando sobre la expresión \ref{ec:gradiente}, con el objetivo de obtener una ecuación similar a la expresión \ref{ec:SPH15}. En Liu [cite:@Liu-Liu03] se concluye que la ecuación discreta con la que es posible calcular la ecuación discreta para calcular el gradiente, que se expresa en términos de :

\begin{equation}\label{ec:SPH17}
\nabla\cdot \tilde{f}(r_i)=-\sum_{j\in\mathcal{N}(i)} \frac{m_j}{\rho_{j}}f(r_j)\cdot \nabla W(r_i-r_j,h),
\end{equation}

donde $\nabla W$ es la función kernel que se particulariza sobre cada una de las  $i$ partículas en las que se ha discretizado el fluido a simular.

Teniendo en cuenta la ecuación \ref{ec:SPH17}, y considerando la condición de compacidad, se puede obtener la ecuación discreta para calcular la derivada parcial para cualquier orden diferencial. La expresión que permite hacer ese cálculo es:

\begin{equation}\label{ec:deDerivadaDiscreta}
\nabla^l\cdot \tilde{f} (r)=-\sum_{j\in\mathcal{N}(i)} \frac{m_j}{\rho_{j}}f(r_j)\cdot \nabla^l W(r-r_j,h),
\end{equation}

Las expresiones obtenidas permite simplificar el cálculo de las complejas ecuaciones que describen la dinámica del fluido. Sin embargo, estas ecuaciones presentan dos importantes limitaciones:

1. Que la función kernel debe ser compacta y la partícula $i$, sobre las que se particulariza cada función kernel, deben estar lejos del contorno del fluido.

2. Las ecuaciones \ref{ec:deDerivadaDiscreta}, particularizadas para cada $l$, no satisfacen la conservación del momento, tal como advierten [cite:@Price12; @Monaghan92]. Para solventar este problema Monaghan [cite:@Monaghan92] propone el desarrollo de ecuaciones simétricas basadas en la regla de la cadena. El proceso que Monaghan sigue se describirá a continuación.

*** Formulación simétricas de las derivadas de las ecuaciones en SPH

Tal como se ha mencionado en la sección anterior, las ecuaciones discretas del método SPH obtenidas, aunque cumplen los criterios analíticos, nos satisfacen la conservación del momento, es decir, no satisface en principio acción--reacción. Monaghan [cite:@Monaghan92] advierte de este hecho y propone una metodología, basada en la regla de la cadena, para obtener ecuaciones simétricas que satisfagan dicha ley de conservación. Las ecuaciones que permiten simetrizar las derivadas parciales de las funciones desconocidas son \ref{ec:SPH18} y \ref{ec:SPH19}:

\begin{equation}\label{ec:SPH18}
\nabla^l f(r)=\frac{1}{\rho}\left[
\nabla^l \left(\rho f(r)\right)-
f(r)\nabla^l \rho
\right],
\end{equation}

\begin{equation}\label{ec:SPH19}
\nabla^l f(r)=\rho\left[
\nabla^l\left(\frac{f(r)}{\rho}\right)+
\frac{f(r)}{\rho^2}\nabla^l\rho
\right].
\end{equation}

donde $\rho$ hace referencia a la densidad de masa.

# %Las dos identidades anteriores pueden sustituirse por la integral en (11).


Análogamente a como se hizo para calcular la  ecuación \ref{ec:SPH17}, se puede operar sobre las ecuaciones \ref{ec:SPH18} y \ref{ec:SPH19}. Tras realizar este proceso, tal como se describe en Moanghan [cite:@Monaghan92], se consiguen las ecuaciones \ref{ec:SPH20} y \ref{ec:SPH21}.

# %Siguiendo el mismo procedimiento de aproximación utilizado para obtener la ecuación \ref{ec:SPH17} se va aplicar a las %ecuaciones \ref{ec:SPH18} y \ref{ec:SPH19}.  Con ello, estas dos ecuaciones
# %Extrapolando este resultado para el caso de la divergencia se tiene:
\begin{equation}\label{ec:SPH20}
\nabla^l \tilde{f}(r_i) = \frac{1}{\rho_i}
\left[ \sum_{j=1}^{N}m_j\left[f(r_j)-f(r_i)\right]\nabla^l_i W_{ij}
\right]
\end{equation}

\begin{equation}\label{ec:SPH21}
\nabla^l \tilde{f}(r_i) = \rho_i
\left[
 \sum_{j=1}^{N}m_j
 \left[
  \left(\frac{f(r_j)}{\rho_j^2}\right)+
  \left(\frac{f(r_i)}{\rho_j^2}\right) \right]\cdot \nabla^l_i W_{ij}
\right],
\end{equation}

Si bien ambas ecuaciones son simétricas y cumplen las premisas de SPH, Monaghan recomienda implementar \ref{ec:SPH21} ya que garantiza mejores resultados que utilizando la ecuación \ref{ec:SPH20}.

** Descripción del Método SPH                                     :noexport:

El método de partículas suaves (SPH, por sus siglas en inglés) fue propuesto originalmente por los investigadores G.R. Lucy [cite:@Lucy77] en 1977 y J.J. Monaghan [cite:@Monaghan82] en 1985. En estos trabajos iniciales, se presentó el método como una técnica numérica para resolver ecuaciones de fluidos mediante la representación del fluido como un conjunto de partículas, cada una con su posición y velocidad.

En estas publicaciones se propuso el uso de una función de interpolación suave (/función kernel/) para calcular las propiedades del fluido en cualquier punto del espacio a partir de las posiciones y velocidades de las partículas. Con este método, se logró simular una gran variedad de problemas y geometrías complejas y con movimiento libre de la malla.

En los años siguientes, investigadores como M.L. Beckermann y J.C. Rieger (1994) y M. S. Long (1995) han extendido y mejorado el método, añadiendo mejoras como la posibilidad de simular problemas multi-materiales y la inclusión de términos de viscosidad artificial.

Otros autores incluyen a:

G.R. Liu y M.B. Liu: en su libro "Smooth Particle Hydrodynamics: A Meshfree Particle Method" (2003) presentan una revisión detallada de la historia, fundamentos y aplicaciones del método SPH.

J.J. Monaghan: es uno de los principales investigadores en el desarrollo de la versión original del método SPH. En su trabajo "Smooth Particle Hydrodynamics" (1992) presenta una revisión detallada de los fundamentos y las aplicaciones del método SPH.

D.J. Price: es otro investigador importante en el desarrollo del método SPH. En su trabajo "Smooth Particle Hydrodynamics: A Review of Recent Developments" (2012) presenta una revisión actualizada de los fundamentos y las aplicaciones del método SPH.

** Formulación del Método SPH                                     :noexport:

La formulación integral de las ecuaciones del método SPH incluye tres pasos básicos:

- Calculo de la densidad de cada partícula: se utiliza una función de suavizado (como por ejemplo, una función de Kernel Gaussiana) para interpolación entre las partículas y calcular la densidad de cada una de ellas. Esto se hace mediante la siguiente ecuación:

- Calculo de la velocidad de cada partícula: una vez que se conocen las densidades de todas las partículas, se puede calcular la velocidad de cada una de ellas utilizando la ecuación de movimiento y teniendo en cuenta las fuerzas que actúan sobre ellas. Esto se hace mediante la siguiente ecuación:

- Actualización de la posición de cada partícula: una vez que se conocen las velocidades de todas las partículas, se puede actualizar su posición utilizando la siguiente ecuación:

  Es importante tener en cuenta que estas ecuaciones son solo una parte de la formulación completa del método SPH. Además, hay muchas variantes y modificaciones posibles de estas ecuaciones para mejorar la precisión y robustez del método.

* Búsqueda de partículas vecinas

** Introducción

La búsqueda de partículas vecinas es una de las tareas fundamentales en el método SPH. Tal como se indicó en el Capítulo [[*Fundamentos del Método SPH]], el modo en que se propagan las interacciones, en el método SPH, es a través de las partículas que se encuentran dentro del dominio soportado de la función kernel, las partículas vecinas. Determinar cuáles son las partículas vecinas de cada una de las partículas que componen el modelado del fluido, constituye uno de los retos más importantes en la simulación mediante SPH, desde un punto de vista de consumo de tiempo de cómputo. Es decir, resulta necesario encontrar las partículas vecinas de una partícula dada para poder calcular las propiedades del fluido en ese punto utilizando la función kernel.

Hay varios métodos para buscar partículas vecinas en SPH. Algunos de los métodos más comunes incluyen:

- /Listas de vecindad estáticas/: en este método, se construye una lista de vecindad estática para cada partícula al principio de la simulación y se utiliza para todo el tiempo de simulación. Es importante reconstruir la lista de vecindad en caso de que las partículas se salgan de su vecindario original.

- /Búsqueda vecinal dinámica/: en este método, se buscan las partículas vecinas de una partícula dada en cada paso de tiempo. Se puede utilizar estructuras de datos como el octree o el kd-tree para hacer esta búsqueda de manera eficiente.

- /Grids/: Es una aproximación de malla de cuadros regular, es decir, se divide el espacio en celdas regulares y se clasifican las partículas en las celdas correspondientes, permitiendo una búsqueda eficiente de las partículas vecina.

- /Búsqueda exhaustiva o por fuerza bruta/:

En general, el tiempo de cálculo para la búsqueda vecinal es proporcional al número de partículas, y puede ser un cuello de botella importante en las simulaciones con un alto número de partículas. Por esta razón, es importante seleccionar el método de búsqueda vecinal adecuado para cada simulación y optimizarlo para mejorar el rendimiento.

** Búsqueda de vecinas mediante Fuerza bruta

La búsqueda de vecinos en el método de partículas suaves (SPH) mediante fuerza bruta consiste en comparar la posición de cada partícula con la posición de todas las demás partículas para encontrar las partículas vecinas. Es una técnica simple, pero tiene un tiempo de ejecución que crece de manera cuadrática con el número de partículas, lo que la hace ineficiente para simular grandes conjuntos de partículas.

En esta técnica se recorren todas las partículas, y se compara su posición con la de cada otra partícula para determinar si la distancia es inferior al radio del dominio soportado, $h$, de la función kernel. Se puede utilizar un radio fijo o un radio variable para determinar el dominio soportado, tal como se sugiere en Price [cite:@Price12].

Este método es útil para pequeñas cantidades de partículas, pero se vuelve ineficiente para sistemas grandes debido a su complejidad computacional. En lugar de esto, se recomiendan técnicas de búsqueda vecinal más eficientes, como el uso de estructuras de datos como /octree/, /kd-tree/ o etiquetado /hash/.

** Búsqueda basada en Grids con marcado Hashing

La búsqueda de vecinos basada en etiquetado hash es una técnica utilizada para encontrar partículas vecinas en el método de partículas suaves (SPH). Esta técnica se basa en el uso de una tabla hash para almacenar las partículas en diferentes "celdas" en función de su posición en el espacio.

Sucintamente, esta técnica opera sobre divisiones del espacio mediante mallas, cada una de las cuales, y siempre que contengan al menos una partícula, es marcada o etiquetada con un número primo obtenido de una operación lógico-algebraica, la función hash. Luego, se buscan las partículas vecinas a través de un recorrido de las celdas adyacentes a la celda de la partícula dada.

La ventaja de este método es que, al clasificar las partículas en las celdas, se puede limitar el número de partículas que se deben revisar para encontrar vecinos a solo aquellas en las celdas adyacentes. Esto reduce significativamente el tiempo de cómputo que mejora conforme aumenta el número de partículas a simular y permite realizar simulaciones con un gran número de partículas.

Sin embargo, esta técnica tiene algunas desventajas. El problema es que si el número de partículas es relativamente bajo, del orden de algunos miles, el procesamiento hash puede ser más costoso que el de búsqueda exhaustiva. Además, no existe una función hash perfecta por lo que se requiere de un filtrado posterior para evitar la denominada colisión por valor hash, tal como menciona Kelager [cite:@Kelager06].

En general, la búsqueda de vecinos basada en etiquetado hash es una técnica eficiente para encontrar vecinos en SPH, pero requiere una buena comprensión de los detalles y puede requerir ajustes para adaptarse a diferentes situaciones.
* Método de integración temporal

La ecuación de NS tiene dependencia espacial y temporal. La componente espacial, esto es, el gradiente, el laplaciano y la densidad la calculamos mediante el método SPH, descrito en el capítulo [[*Fundamentos del Método SPH]]. Sin embargo, la componente temporal, evidenciada mediante la derivada sustantiva, requiere de un tratamiento específico no contemplado en el método SPH. Para tal fin se utilizan otros métodos numéricos tanto explícitos como implícitos, en Modak et al. [cite:@Modak-Sotelino02] se realiza una descripción de las diferentes metodologías. En nuestro proyecto nos vamos a centrar en los métodos explícitos y semi-implícitos algunos de los cuales procederemos a describir a continuación.

** Fundamentos del Método de integración Temporal

La idea principal bajo la que operan todos estos métodos numéricos es la de dividir el tiempo en pequeños intervalos, en el que cada uno se separa del anterior por un pequeño incremento de tiempo, ampliamente conocido en el ámbito de las CG como $\Delta\;t$.

En otras palabras, la idea subyacente en la integración temporal numérica es aproximar la solución de una ecuación diferencial ordinaria (EDO) mediante el uso de valores discretos en intervalos de tiempo específicos, en lugar de tratar de encontrar la solución analítica exacta. Esto se logra mediante el uso de un algoritmo numérico, como un método de integración temporal, que utiliza una serie de pasos para avanzar en el tiempo y calcular los valores de la solución en momentos discretos.

Todos los métodos existentes se pueden dividir en dos categorías: métodos explícitos y métodos implícitos. La principal diferencia entre ellos radica en que mientras que en los explícitos, se considera que las acciones sobre el sistema, /las fuerzas/, se mantienen constantes a los largo de todo el paso de tiempo, lo que implica que es posible conocer las aceleraciones en el siguiente paso, ya que son las mismas que en el paso actual. Conocida la aceleración actual, es fácil resolver las ecuaciones de la velocidad y de la posición. Esta hipótesis, la de que las fuerzas se mantienen constante dentro de cada paso de tiempo, no es considerada en los implícitos, por lo que no se conoce ni la aceleración, ni la velocidad, ni la posición en el siguiente paso. Por lo tanto, es necesario poner en función de la aceleración, tanto la velocidad, como la posición y la ecuación obtenida, sustituirla en la ecuación dinámica. Todo ello implica una complejidad que se hace mayor si la aplicamos al sistema de partículas con el que se modela el fluido, ya que, en ese caso, para cada paso de tiempo hay que resolver un sistema de ecuaciones con un número de ecuaciones igual al de partículas.

Computacionalmente, los métodos explícitos son más sencillos de implementar y su resolución es casi directa, ya que con la aceleración se despeja directamente la velocidad y con la velocidad, y/o la aceleración (dependiendo del orden del método de integración), la posición, sin necesidad de procesar un sistema de ecuaciones. No obstante, la principal limitación de los explícitos radica en la hipótesis fundamental en la que se basan: "las fuerzas se mantienen constante dentro de cada paso de tiempo", y esto sólo se satisface para pasos de tiempo muy cortos, del orden de fracciones de milésimas de segundo, y en problemas que no sean /stiffness (véase  Modak et al. [cite:@Modak-Sotelino02])/. Así pues, se puede afirmar, que los métodos explícitos tienen su convergencia a resultados correctos condicionada, mientras que los implícitos se puede decir que no está condicionada, tal como se expone en Modak et al. [cite:@Modak-Sotelino02].

Existe otra posibilidad que aúna características de métodos explícitos e implícitos, son los denominados métodos semi-implícitos. En síntesis, estos métodos consideran la hipótesis de los implícitos, es decir, consideran que las fuerzas se mantienen constantes dentro de cada paso de tiempo, con lo que se conoce la aceleración y con ella se calcula la velocidad en el siguiente paso, y con esta nueva velocidad y aceleración se obtiene la nueva posición. Con este proceso se mejoran los resultados, con pasos de tiempo hasta dos órdenes de magnitud mayores que en los explícitos. Sin embargo, su convergencia sigue estando condicionada. A pesar de ello, los métodos semi-implícitos son muy utilizados en el ámbito de CG y es la tipología que vamos a seleccionar en nuestro proyecto.

Algunos de estos algoritmos numéricos son por ejemplo:

- /Método de Euler/: Este es uno de los métodos de integración temporal más simples y fáciles de implementar en comparación con otros. Utiliza una aproximación de diferencias finitas para calcular el valor de la solución en el siguiente paso temporal a partir del valor actual. Sin embargo, el método de Euler es poco preciso y puede dar lugar a soluciones inestables si el paso temporal es demasiado grande.

- /Método de Runge-Kutta/: Este es uno de los métodos de integración temporal más populares y utilizados. Utiliza una combinación de aproximaciones de diferencias finitas y diferencias progresivas para calcular el valor de la solución en el siguiente paso temporal. Es más preciso y estable que el método de Euler, pero también es más complejo de implementar.

- /Euler semi-implícito/: Calcula las nuevas velocidades a partir las velocidades actuales y de las nuevas aceleraciones. Para las nuevas posiciones, considera las posiciones actuales, pero utiliza las nuevas velocidades y aceleraciones.

Es este último el que utilizaremos en nuestro simulador.

** Explicación Método Euler semi-implícito

** Introducción                                                   :noexport:

La ecuación de NS tiene dependencia espacial y temporal. La componente espacial, esto es, el gradiente, el laplaciano y la densidad la calculamos mediante el método SPH, descrito en el capítulo [[*Fundamentos del Método SPH]]. Sin embargo, la componente temporal, evidenciada mediante la derivada sustantiva, requiere de un tratamiento específico no contemplado en el método SPH. Para tal fin se utilizan otros métodos numéricos tanto explícitos como implícitos, en Modak et al. [cite:@Modak-Sotelino02] se realiza una descripción de las diferentes metodologías. En nuestro proyecto nos vamos a centrar en los métodos explícitos y semi-implícitos algunos de los cuales procederemos a describir a continuación.

- Método de Euler: es el método más simple de integración temporal. Consiste en calcular las nuevas posiciones y velocidades de las partículas a partir de las velocidades y aceleraciones actuales utilizando las ecuaciones de movimiento. Sin embargo, este método tiene una baja estabilidad temporal y suele ser utilizado solo para problemas simples.

- Método de Euler semi-implícito: es una variante del método de Euler que se utiliza para mejorar la estabilidad temporal. Consiste en calcular las nuevas posiciones de las partículas a partir de las velocidades actuales y las aceleraciones interpoladas, mientras que las nuevas velocidades se calculan a partir de las aceleraciones actuales.

- Método de Verlet: es un método de integración temporal que se basa en el uso de la posición actual y la posición anterior para calcular la velocidad y la nueva posición de las partículas. Es un método más estable que el método de Euler y se utiliza comúnmente en SPH.

** Ecuación fundamental para la integración temporal numérica     :noexport:

La idea subyacente en la integración temporal numérica es la de dividir el tiempo en pequeños intervalos (llamados pasos de tiempo) y calcular la solución en cada uno de estos intervalos. En cada paso de tiempo, se utilizan las condiciones iniciales (como la posición y velocidad de las partículas) y las ecuaciones de movimiento para calcular la solución en el siguiente paso de tiempo. Esto se repite sucesivamente para todos los pasos de tiempo, generando una serie de soluciones que representan la evolución del sistema en el tiempo.

Así, la discretización temporal numérica consiste en aproximar la solución de un sistema dinámico (como las ecuaciones de movimiento) mediante una serie de pasos discretos en el tiempo.

La precisión de la solución numérica dependerá del tamaño del paso de tiempo elegido y del método de integración temporal utilizado. Los métodos de integración temporal más precisos son los de orden superior, como el método de Runge-Kutta, que utilizan más información para calcular la solución en cada paso de tiempo, pero son también más computacionalmente costosos, lo cual limita su uso en la simulación de fluidos dentro del ámbito de CG.

En resumen, la integración temporal numérica busca aproximar la solución de un sistema dinámico dividiendo el tiempo en pequeños intervalos y utilizando las condiciones iniciales y las ecuaciones de movimiento para calcular la solución en cada paso de tiempo. La precisión de la solución depende del tamaño del paso de tiempo y del método de integración temporal utilizado.

(Ecuaciones)

** Comparativa entre métodos implícitos y explícitos              :noexport:

En la integración temporal numérica, los métodos implícitos y explícitos se refieren a cómo se utilizan las soluciones en un paso de tiempo para calcular la solución en el siguiente paso de tiempo.

Los métodos explícitos son aquellos en los que las soluciones en un paso de tiempo son utilizadas directamente para calcular la solución en el siguiente paso de tiempo. Es decir, las soluciones en un paso de tiempo no afectan a las soluciones en el siguiente paso de tiempo. Los métodos explícitos son fáciles de implementar y rápidos, pero su estabilidad temporal esta limitada por el tamaño del paso de tiempo. Ejemplos de métodos explícitos son el método de Euler, Verlet.

Por otro lado, los métodos implícitos son aquellos en los que las soluciones en un paso de tiempo son utilizadas para calcular las soluciones en el siguiente paso de tiempo de manera implícita, a través de la resolución de un sistema de ecuaciones no lineales. Estos métodos son más estables temporalmente, pero requieren más cálculos y son más complejos de implementar. Ejemplo de métodos implícitos son los métodos de Runge-Kutta, Euler-implícito.

En resumen, la diferencia entre los métodos implícitos y explícitos de integración numérica radica en cómo se utilizan las soluciones en un paso de tiempo para calcular la solución en el siguiente paso de tiempo. Los métodos explícitos son fáciles de implementar y rápidos pero con menor estabilidad temporal, mientras que los métodos implícitos son más estables temporalmente pero más complejos de implementar.

* Colisiones

En el mundo real los fluidos interactúan con objetos y debido a esta interacción se modifica su comportamiento dinámico. Cuantitativamente, la interacción o colisión del fluido con objetos se modela imponiendo restricciones tanto a las variables de estado como a las magnitudes dinámicas. Estas restricciones son conocidas como condiciones de contorno y son las responsables de alterar el flujo del fluido descrito por la ecuación NS.

Al tratar en nuestro proyecto con la metodología SPH que trata el conjunto de nuestro fluido como partículas independientes, se puede suponer que la forma geométrica de estas partículas será la de un punto o, de una forma más compleja, la de una esfera, ya que las operaciones para detectar que una partícula (punto o esfera) ha colisionado con un sólido rígido son análogas. Sólo que cuando se considera como una esfera habrá que tener en cuenta el radio.

Hay un consenso en dividir la colisión en dos partes, la primera es la detección, la segunda es la respuesta. En la detección se realizan operaciones vectoriales cuyo objetivo es determinar la distancia relativa entre las partículas y los objetos con los que puede colisionar. En caso de que se detecte colisión, se «activa» la segunda etapa. En la segunda etapa, la etapa de respuesta, se realizan operaciones sobre las magnitudes dinámicas y variables de estado de la partícula de modo que satisfagan las condiciones de contorno.

** Detección de la colisión

Dependiendo de la simetría del contorno, el proceso de detección puede simplificarse, tal como describiremos a continuación. En nuestro simulador distinguiremos entre dos tipos de contornos, los de alta simetría geométrica, relativamente fáciles de operar en la detección, y los que tienen una geometría más compleja que normalmente están discretizados mediante triángulos. En las siguientes secciones vamos a realizar una descripción de las distintas técnicas de detección utilizadas.

*** Colisión con cuerpos rígidos con alta simetría

A continuación, se desarrollará una explicación sobre las diferentes colisiones que puede tener una esfera, ya que en nuestro simulador cada partícula es tratada geométricamente como una esfera, con otros cuerpos rígidos.

**** Colisión caja

Para saber si una esfera (o partícula en nuestro caso) ha colisionado con un cuerpo geométrico con la forma de un cubo o hexaedro rectangular, que en lo sucesivo designaremos como hexaedro. Sabiendo que un hexaedro tiene todos sus lados perpendiculares podemos definir este mismo a través de los límites de sus tres dimensiones, o dicho de otra manera las posiciones de sus extremos que llamaremos límites. Una vez conocidos los límites inferiores y superiores de nuestro cuerpo geométrico podemos razonar si la posición de nuestra partícula se encuentra dentro de la figura geométrica y sus coordenadas son menores o superiores a alguno de los límites del cubo esta ha colisionado con alguna de las caras del cubo. Análogamente si suponemos que la partícula se encuentra en el exterior de la caja seguiríamos necesitando los mismos parámetros para definir nuestro hexaedro, pero esta vez la colisión se detectaría si estuviera dentro de esos límites.

#+CAPTION: Colisión caja
#+ATTR_LATEX: :width 8cm
[[./graficos/caja-vacia.pdf]]

Ya que los dos métodos son análogos para la detección nos centraremos en explicar la partícula dentro del cubo ya que es uno de los usos más comunes para representar un fluido contenido en un espacio cerrado.

La manera de implementar esto de una manera algorítmica se puede definir con la siguiente expresión lógica:
\begin{align*}
(P_x < \lim X_{inf} &\lor P_x > \lim X_{sup})\; \lor \\
(P_y < \lim Y_{inf} &\lor P_y > \lim Y_{sup})\; \lor \\
(P_z < \lim Z_{inf} &\lor P_z > \lim Z_{sup})
\end{align*}

**** Colisión cilindro

Igual que con otra colisión con una forma geométrica simple conocida podemos resolver si se ha producido una colisión entre nuestra partícula y el cuerpo rígido conociendo su altura o el límite de su coordenada $Y$ (suponiendo que el cilindro tiene una posición vertical paralela al eje Y de nuestro sistema global), el radio del cilindro con respecto a su eje y el eje mismo. La partícula estará colisionando si la distancia de la partícula hacia el eje es menor que el radio y si cumple la condición de estar entre los límites de la altura del cilindro. La partícula ha colisionado con el cilindro.

La manera de implementar esto de una manera algorítmica se puede definir con la siguiente expresión lógica:
\[
(P_y < \lim Y_{inf} \lor P_y > \lim Y_{sup}) \land (\text{distancia} < \text{radio})
\]
siendo la distancia la magnitud del vector entre la posición de la partícula y el eje del cilindro, expresado matemáticamente sería:
\[
\text{Distancia} = \left|(P_x - \text{eje x}, 0, P_z - \text{eje z})\right|
\]

#+CAPTION: Colisión cilindro
#+ATTR_LATEX: :width 8cm
[[./graficos/cilindro.pdf]]

**** Colisión esfera

La colisión esfera partícula es una de las más sencillas de implementar y entender pues solo se necesita conocer el radio y el centro de la esfera con la que se va a colisionar para calcular la distancia entre nuestra partícula y la esfera con la que se quiere detectar la colisión. Al conocer estos parámetros solo necesitaríamos aplicar una operación vectorial que nos dijera el módulo o distancia entre nuestra partícula y el centro y una vez obtenida esa distancia calcular si es menor que el radio de la esfera, si el resultado es verdadero nuestra esfera ha colisionado con la partícula.

#+CAPTION: Colisión esfera
#+ATTR_LATEX: :width 8cm
[[./graficos/esfera.pdf]]

La manera de implementar esto de una manera algorítmica se puede definir con la siguiente fórmula:

\[
(\text{distancia} < \text{radio})
\]

siendo la distancia la magnitud entre la posición de la partícula y el centro de la esfera, expresado matemáticamente sería:
\[
\text{Distancia} = \left|(P_x - C_x, P_y - C_y, P_z - C_z)\right|
\]
*** Colisión con contorno discretizado en triángulos

La mayoría de los modelos existentes no son figuras geométricas con alta simetría que nos permiten calcular rápidamente sus colisiones, si no que son mallas de triángulos que forman todo tipo de figuras, además el estándar en la industria es que los modelados sean mallas de triángulos ya que con esto se puede representar cualquier figura o modelo, desde una caja 8 triángulos hasta al famoso conejo /Stanford bunny/ compuesto por 69.451 triángulos.

#+CAPTION: Stanford bunny triángulos
#+ATTR_LATEX: :width 8cm
[[./graficos/caja-conejo.pdf]]

Para ello expondremos los pasos necesarios para calcular si una partícula ha colisionado con un triángulo, debido a que esta seria la operación que tendríamos que aplicar a todos los triángulos de un modelo discretizado por estos.

**** Colisión triangulo

La colisión de triángulo con una partícula es más costosa computacionalmente, ya que resulta en una gran cantidad de operaciones matemáticas para calcular si la partícula ha colisionado o no con un triángulo. Esto conlleva un alto coste computacional que “perderíamos” si la partícula no llegara a colisionar, a pesar de esto como hemos explicado anteriormente los modelos discretizados por triángulos son ampliamente utilizados y la técnica de detección de una colisión con un triángulo también lo es.

Los parámetros necesarios para conocer si existe la colisión entre una partícula y un triángulo en un espacio 3D es conocer los vértices del triángulo junto con la posición de la partícula.

#+CAPTION: Colisión triángulo
#+ATTR_LATEX: :width 8cm
[[./graficos/triangulo.pdf]]

Este proceso denominado campo de distancia nos permite determinar si existe colisión entre la partícula y el triángulo independientemente de la orientación y posición en la que se encuentre el triángulo. Para ello nuestro primer paso es determinar si la partícula está a una distancia en la que es posible que colisionara con el triángulo.

Los pasos a seguir son los que se relacionan a continuación:

1. Determinamos la posición de cada vértice del triángulo junto con la posición de la partícula en ese instante. Escogemos dos aristas del triángulo y calculamos el producto vectorial de esos dos vectores lo que da lugar a un vector perpendicular al triángulo, que al calcular el módulo de este producto vectorial obtenemos la superficie de nuestro triángulo. Como se observa en la figura [[fig:triangulo01]].

   #+NAME: fig:triangulo01
   #+CAPTION: Producto vectorial
   #+ATTR_LATEX: :width 10cm
   [[./graficos/producto-vectorial.pdf]]

2. Obtenemos también el vector resultante de nuestra partícula hacia el vértice del que nacen nuestros vectores o aristas elegidos. Como vemos en la figura  [[fig:triangulo02]].

   #+NAME: fig:triangulo02
   #+CAPTION: Representación del vector distancia desde el vértice elegido hacia la partícula
   #+ATTR_LATEX: :width 10cm
   [[./graficos/producto-triangulo.pdf]]

3. Calculamos el producto escalar del producto vectorial junto al vector con dirección hacia la partícula. La magnitud de nuestro producto escalar es el volumen de nuestro trapecio imaginario.

4. Si la altura de ese trapecio es menor a una distancia dada en la que es posible que nuestra partícula colisione, entonces comprobamos si la partícula ha intersectado con nuestro triángulo.

5. Una vez realizado este proceso para saber si la partícula está a una distancia del triángulo en la que es posible que colisione, calculamos si la partícula ha colisionado en nuestro triángulo. Para este segundo proceso necesitamos proyectar la posición de nuestra partícula en la superficie o plano.

Para proyectar un punto sobre un plano, respetando las propiedades que lo definen, se utiliza la siguiente fórmula:

\[
P_pr = \Biggl(\biggl(P_x + \dfrac{\text{altura}}{\text{superficie}}\biggr) S_x, \biggl(P_y + \dfrac{\text{altura}}{\text{superficie}}\biggr) S_y, \biggl(P_z + \dfrac{\text{altura}}{\text{superficie}}\biggr) S_z\Biggr),
\]

siendo $P$ la posición de la partícula, altura es la distancia de nuestra partícula al triangulo, superficie es la magnitud del producto vectorial que define el plano y $S$ es el producto vectorial

#+NAME: fig:triangulo03
#+CAPTION: Representación del punto proyectado sobre el plano
#+ATTR_LATEX: :width 10cm
[[./graficos/triangulo-punto.pdf]]


Una vez proyectada la posición de la partícula es necesario comprobar si la partícula está dentro del triángulo. El proceso que utilizaremos para calcular que el punto se encuentra en el interior del triángulo es a partir de los ángulos de este, ya que la suma de los ángulos del punto proyectado hacia los vértices del triángulo tiene que sumar 2\pi.

#+NAME: fig:triangulo04
#+CAPTION: Representación del punto proyectado junto con las aristas interiores apuntando hacia los vértices
#+ATTR_LATEX: :width 10cm
[[./graficos/triangulo-punto2.pdf]]

Y por geometría el ángulo de cada triángulo interior es el arco coseno del producto escalar de las dos aristas entre su magnitud.

\[
\theta = \cos^{-1} \left( \frac{\mathbf{A}\cdot\mathbf{B}}{|\mathbf{A}||\mathbf{B}|}\right)
\]

Calculamos esto para cada ángulo interior y los sumamos para comprobar si se encuentra dentro del triángulo en cuyo caso ha colisionado.

** Respuesta de la colisión

Hasta ahora solo se ha determinado si la partícula ha colisionado con alguna geometría, pero no como responde esta misma ni que valores internos se modifican.

El segundo paso para simular correctamente una colisión en el medio continuo de un fluido, compuesto por partículas, es entender no solo si la partícula ha colisionado con alguna geometría si no cómo reacciona ante esa geometría y como cambian las propiedades constitutivas de esta como son por ejemplo la velocidad y la posición.

En un primer momento se puede llegar a pensar que, igual que en la colisión podemos llegar a necesitar varias respuestas para diferentes cuerpos geométricos, pero se puede estandarizar la respuesta de la colisión para diferentes tipos de detecciones (figuras geométricas como cubos, esferas, cilindros o detecciones basadas en distancia que usan triángulos como se hace referencia en el apartado anterior). Este proceso de estandarización se puede llevar a cabo siempre que almacenemos en la estructura de nuestros modelos, ya sea una malla de triángulos o una figura geométrica con alta simetría, los vectores normales de estos planos con respecto a la dirección que queremos que interactúe la partícula.

Remarcar también que la técnica que se explica a continuación esta avalada por diferentes autores como Di Monaco et al. [cite:@MonManGal.etal11], Li et al. [cite:@li2014efficient] o Perea et al. [cite:@Perea-Cordero18]

Nuestro objetivo es hallar la velocidad final, una de las propiedades constitutivas de nuestra partícula que queremos modificar cuando se encuentra con una colisión, esta velocidad se resuelve a través de varias operaciones vectoriales que nos permiten conocer el vector resultante de velocidad a asignar. Para esto también necesitaremos algunos parámetros como la tasa de rozamiento y rebote que modificaran nuestra velocidad final, el primer paso es obtener la velocidad incidente al detectarse la colisión, una vez realizado esto con el vector normal almacenado calculamos el vector proyección de la velocidad incidente sobre el vector normal del plano además de la velocidad inicial tangencial que es la resultante de la resta de los vectores de la velocidad inicial menos la proyección de la velocidad inicial sobre el plano. A estas dos velocidades descompuestas le aplicamos una tasa de rebote y una tasa de rozamiento respectivamente. La suma de estos dos vectores de velocidad descompuesta da como resultado la velocidad resultante final que le aplicamos a nuestra partícula una vez detectada la colisión.

#+CAPTION: Representación esquemática de las tres fases para corregir la velocidad: antes de la colisión, durante la colisión y después de la colisión
#+ATTR_LATEX: :width 12cm
[[./graficos/pelotas.pdf]]

Para la propiedad constitutiva de la posición en la partícula el proceso es similar. Necesitamos obtener la posición una vez detectada la colisión de la partícula con algún sólido rígido, y a este vector de la posición inicial le aplicamos la suma de una tolerancia de posición que es el resultado del producto del vector normal almacenado en el plano por una tasa de penetración, esto nos posiciona la partícula para que salga del estado de colisión.

#+CAPTION: Representación esquemática de la corrección de la posición después de la colisión
#+ATTR_LATEX: :width 6cm
[[./graficos/rebote.pdf]]

Esta respuesta estandariza es extremadamente útil ya que permite a través del almacenamiento de los vectores normales de las figuras geométricas con los que colisiona y las propiedades inherentes de los vectores resolver uno de los problemas principales en las colisiones el cual es tratar con aristas que son la intersección de dos o más figuras geométricas diferentes ya que la suma de estos vectores normales resulta en una dirección coherente en el que la partícula modifica su velocidad y posición. Además de permitirnos implementar diferentes métodos de detección de colisiones.

* Características de las herramientas de implementación del proyecto
** Introducción
** Características del lenguaje C

Como ya hemos visto nuestro proyecto de simulación de fluidos se ha construido sobre dos librerías para unos resultados iniciales que luego se exportaran a un motor de renderizado.

Debido a que el objetivo de este proyecto se ha enfocado en reducir lo máximo posible el tiempo de calculo necesario para el muestreo de los resultados. Se ha utilizado el lenguaje C debido a las siguientes razones. Tanto CUDA como OpenGL tienen soporte en C cuya incorporación en este mismo lenguaje esta documentado, mantenido y siendo usado por varios desarrolladores.

C también es por si solo uno de los lenguajes multiplataforma que permite una gran eficiencia del código y es el mas utilizado actualmente en el desarrollo de software. Debido a que permite estructuras típicas de los lenguajes de alto nivel pero también nos da acceso a funciones de control de bajo nivel como puede ser el manejo de la memoria. Características que nos resultan muy útiles a la hora de desarrollar nuestro proyecto.

** Características del lenguaje CUDA

*** Introducción

Seguidamente se va a presentar la herramienta sobre la que se fundamenta uno de los pilares de este proyecto el cual es la mejora de rendimiento del simulador, puesto que el coste computacional es uno de los mayores problemas en el ámbito de las /Computer Graphics/. Para solventar este problema se ha decidido utilizar CUDA para acelerar los cálculos. Por ello vamos a hacer una introducción sobre lo que es CUDA y como opera.

CUDA acrónimo en ingles de /Compute Unified Device Architecture/ es el nombre de la arquitectura desarrollada por NVIDIA (una de las desarrolladoras mas importantes de tarjetas gráficas) para sus tarjetas gráficas. El objetivo de esta arquitectura es hacer asequible las tarjetas gráficas a cualquier programador a través de lenguajes de alto nivel y así poder utilizarlas para realizar cómputos de propósito general. Esto quiere decir que podemos desarrollar aplicaciones que aprovechen el potencial de la arquitectura CUDA a través de lenguajes de alto nivel como pueden ser C, OpenCL, Fortran, C++, DirectX Compute, Python…

#+CAPTION: Arquitectura CUDA
#+ATTR_LATEX: :width 8cm
[[./graficos/cuda-arquitectura.pdf]]

*** Arquitectura CUDA

A continuación vamos a describir como se compone físicamente una GPU (/Graphic Processin Unit/) CUDA.

Una GPU CUDA esta formada por varios multiprocesadores cada uno de ellos esta constituido por distintos espacios de almacenamiento y cientos de núcleos de computo, estos núcleos de computo son los encargados de ejecutar las instrucciones serian similares a una ALU en un procesador tradicional, cada uno de estos núcleos de computo según la terminología de CUDA son llamados CUDA cores.

#+CAPTION: CUDA core
#+ATTR_LATEX: :width 15cm
[[./graficos/cuda-core.pdf]]

Una tarjeta gráfica con arquitectura CUDA se puede clasificar como un computador con arquitectura SIMD (/Single Instruction Multiple Data/), es decir, un flujo único de instrucciones un flujo múltiple de datos. Esto permite aprovechar el paralelismo de datos dentro de una aplicación, ya que todos los núcleos de la GPU ejecutan la misma instrucción sobre datos distintos, esta característica fue una de las claves para decidir usar CUDA sobre otras herramientas ya que en el ámbito de las CG y  en nuestro caso una simulación lagrangiana con magnitudes altas en el numero de partículas, siempre vamos a utilizar las mismas operaciones sobre estas lo que en un sistema tradicional requeriría un alto coste computacional ya que tiene que ejecutar estas operaciones de manera secuencial sobre cada partícula, usando CUDA nos permite ejecutar estas mismas operaciones de manera paralela.

Esta ventaja de paralelismo también se aplica sobre diferentes aplicaciones ya que permite incrementar el rendimiento aprovechando las altas prestaciones de una GPU para realizar calculo paralelo.

Remarcar también que este es un modelo de computación heterogéneo formado por una CPU y GPU

#+CAPTION: Cores
#+ATTR_LATEX: :width 8cm
[[./graficos/cores.pdf]]

En este modelo computacional la CPU se encarga de ejecutar la parte secuencial de la aplicación mientras que la GPU se ocupa de la parte paralela.

*** Programación en CUDA

En los capítulos anteriores hemos revisado la composición de la arquitectura CUDA y en este apartado vamos a dedicarnos a hacer una breve introducción sobre como se programa en una tarjeta gráfica que no posee una arquitectura CUDA y como esta ultima presenta ventajas ante las otras.

El problema de programar en una tarjeta gráfica tradicional para cómputos de propósito general es que se necesita utilizar lenguajes de programación específicos para gráficos como OpenGL o Cg para programar en la GPU. Esto implica que el desarrollador debe modificar su aplicación para que convirtiera su problema en uno que dibujara triángulos o polígonos, esto limito el uso de las GPUs como parte intrínseca del desarrollo de aplicaciones de propósito general.

Las tarjetas gráficas con arquitectura CUDA por otro lado, se pueden programar utilizando CUDA C/C++, este es un pequeño conjunto de extensiones del lenguaje C/C++ lo que nos permite empezar a programar sobre una tarjeta gráfica teniendo conocimientos de programación en C. Además NVDIA la empresa desarrolladora de las GPUs con arquitectura CUDA, proporciona un compilador y un conjunto de herramientas de desarrollo que facilitan el proceso de creación de aplicaciones.

El principal problema de CUDA es que solo se puede utilizar sobre dispositivos NVDIA, una alternativa valida para cualquier tipo de tarjeta gráfica es OpenCL, sin embargo el proceso de aprendizaje de OpenCL es mucho más costoso en cambio la transición de CUDA C a OpenCL es mucho menor. Son estas las razones además de la proliferación de las tarjetas NVDIA en la mayoría de dispositivos junto con las ventajas anteriormente mencionadas que se ha decidido utilizar esta sobre otras alternativas.

*** Estructura de programación en CUDA C

En los apartados anteriores se ha introducido lo que implica un modelo de computación heterogéneo lo que implica que un programa en CUDA C se va a diferenciar dos partes, una parte correspondiente al código que se va a ejecutar en la tarjeta gráfica, que corresponde a la función que se quiere paralelizar, y la parte correspondiente a la CPU en esta parte del código se ejecutarían funciones secuenciales y el programa principal o main. Este main se ejecuta de forma secuencial en la CPU y en algún momento de esa ejecución secuencial se harán llamadas a la función que se ejecuta en la tarjeta gráfica, cuya ejecución es en paralelo, una vez finalizada la función paralela, se volvería a la parte secuencial de nuestro código que se terminaría de ejecutar en la CPU.

#+CAPTION: Modelo de programación heterogénea
#+ATTR_LATEX: :width 10cm
[[./graficos/prog-heterogenea.pdf]]

Para terminar de entender como se ejecuta CUDA C es importante conocer su terminología básica:

- Host: CPU y su memoria
- Device: GPU y su memoria
- Kernel: Función principal que se ejecuta en el device.
- Hilo (thread): Cada una de las copias del kernel que se ejecuta en el device

  #+CAPTION: Thread
  #+ATTR_LATEX: :width 6cm
  [[./graficos/thread.pdf]]

- Bloque (Block): Conjunto de hilos
  #+CAPTION: Block
  #+ATTR_LATEX: :width 6cm
  [[./graficos/block.pdf]]

- Malla (Grid): Conjunto de bloques

  #+CAPTION: Grid
  #+ATTR_LATEX: :width 8cm
  [[./graficos/grid.pdf]]

Análogamente se puede entender desde el punto de vista del Hardware como se agrupa la memoria en CUDA. Correspondiendo así un hilo se ejecuta en un CUDA core, un bloque se ejecuta en un CUDA Streaming Multiprocessor y una malla se reparte entre todos los multiprocesadores que dispusiera la tarjeta gráfica.

Una vez ya explicada la estructura que posee un programa en CUDA hay que analizar como se comparten datos entre el host y el device.

En primer lugar se copian los datos desde la memoria de la CPU hacia la memoria de la GPU, el siguiente paso consiste en cargar el código de la función kernel en la GPU que se ejecutara en paralelo en tantos hilos como se halla decidido, estos hilos comparten los datos de la memoria de la tarjeta gráfica. Una vez finalizada la ejecución del Kernel se copian los resultados desde la memoria de la GPU a la memoria de la CPU.


*** Texto previo                                                 :noexport:

CUDA (Compute Unified Device Architecture) es una plataforma de cálculo paralelo y un modelo de programación desarrollados por la empresa NVIDIA Corporation para el cálculo general en unidades de procesamiento gráfico (GPU). Con CUDA, los desarrolladores pueden acelerar drásticamente las aplicaciones de cálculo aprovechando la potencia de las GPU.

Algunas de las características más relevantes del lenguaje CUDA son:

- Paralelismo: CUDA permite ejecutar cálculos en paralelo en una GPU, lo que permite acelerar los cálculos y mejorar el rendimiento de las aplicaciones.

- Programación de alto nivel: CUDA es un lenguaje de programación de alto nivel, lo que significa que se parece y se usa como un lenguaje de programación general como C/C++, Java, Python.

- Compatibilidad con lenguajes de programación comunes: CUDA se integra bien con lenguajes de programación comunes como C/C++ y Fortran, lo que permite a los desarrolladores utilizar las funciones de programación de alto nivel de CUDA junto con los lenguajes de programación existentes.

- Modelo de programación paralelo: CUDA proporciona un modelo de programación paralelo basado en tareas de punto flotante de alta precisión, que permite a los desarrolladores dividir una tarea en subprocesos que se ejecutan en paralelo en una GPU.

- Memoria compartida: CUDA permite el acceso a la memoria compartida entre las diferentes unidades de procesamiento en una GPU, lo que permite una mayor flexibilidad en la programación paralela.

- Entorno de desarrollo: NVIDIA proporciona un entorno de desarrollo integrado (IDE) y herramientas de depuración para CUDA, lo que facilita el desarrollo y la depuración de aplicaciones CUDA.

En general, CUDA es un lenguaje de programación eficiente para el desarrollo de aplicaciones paralelas en GPU. Pero es importante notar que solo es compatible con tarjetas gráficas de NVIDIA y que es necesario tener un conocimiento específico de paralelismo y GPU's para sacarle provecho.

#+CAPTION: Sistema de computación en sistemas heterogéneos CPU + GPU
#+ATTR_LATEX: :width 8cm
[[./graficos/CPU+GPU.pdf]]

Pero para entender verdaderamente como funciona CUDA primero hay entender como funciona la programación tradicional o secuencial y como trabaja CUDA con programación en paralelo. La programación secuencial, la que se utiliza mayoritariamente para en toda la computación clásica, es aquella en la que solo se ejecuta una instrucción a la vez y hay que esperar que el ordenador termine para ejecutar la siguiente. Es el modelo de programación clásica y debido a que los sistemas informáticos son extremadamente rápidos en estos momentos no es perceptible. Pero para aplicaciones en las que el tiempo de ejecución es vital y existe un alto coste computacional no se puede permitir ese desperdicio de recursos ya que técnicamente en la programación secuencial al esperar que se acaba cada instrucción se están desperdiciando recursos del sistema en vez de utilizarlos para otra tarea. Es por eso que surge la programación en paralelo en la que varias instrucciones se ejecutan a la vez utilizando la mayor cantidad de recursos disponibles del sistema.

Por otra parte, el desarrollo del hardware ha hecho que los procesadores de las tarjetas gráficas, el componente hardware encargado del procesamiento de datos relacionados con imágenes y vídeos, sean extremadamente potentes en la actualidad, óptimamente capacitadas para este tipo de cálculos intensivos. Su rendimiento es muy superior al que se obtiene con los otros procesadores, utilizados para ejecutar la mayoría de programas. Es en este contexto, donde CUDA realiza un trabajo excelente, al permitir programar paralelamente en estas tarjetas gráficas de una manera sencilla.

CUDA permite utilizar el procesador del sistema y utilizar los múltiples núcleos de programación de las tarjetas gráficas, además de permitir creación de funciones que se ejecutaran paralelamente en los núcleos de GPU.

La tecnología CUDA se basa en dos pilares el /host/ (el procesador principal) y el /device/ (la tarjeta gráfica). El código secuencial se ejecutara en el /host/ y el código que alto coste computacional se ejecutara en el /device/.

#+CAPTION: Modelo de programación heterogénea
#+ATTR_LATEX: :width 10cm
[[./graficos/prog-heterogenea.pdf]]

#+CAPTION: Jerarquía de memoria dentro de la arquitectura CUDA
#+ATTR_LATEX: :width 10cm
[[./graficos/jerarquia-memoria.pdf]]

#+CAPTION: Esquema
#+ATTR_LATEX: :width 10cm
[[./graficos/grid-host.pdf]]

** Características de OpenGL

Una librería gráfica es conjunto de programas que implementan versiones optimizadas de funciones y métodos que facilitan al programador la renderización de gráficos para mostrarlos en un dispositivo electrónico de salida de vídeo, ya sean monitores de computadora o cascos RV. Incluyen rutinas de gestión de texturas, de generación de efectos de iluminación y sombreado, y que pueden aprovechar hardware de las actuales tarjetas gráficas

Existen diferentes librerías gráficas de bajo nivel, es decir, aquellas que permiten sacar el máximo partido al hardware, aunque también son más complejas de programar. De entre estas se pueden destacar debido a su amplio uso en el sector de la computación gráfica, Vulkan, DirectX y OpenGL. Todas ellas tienen sus ventajas e inconvenientes y destacan en ciertos aspectos sobre otros. En este proyecto para una ilustración previa de los resultados se ha utilizado OpenGL.

Debido a que OpenGL no es solo una API o librería si no una especificación de como ciertas funciones tienen que devolver cierto tipos de resultados, se han desarrollado varias librerías implementadas normalmente por los creadores de las tarjetas gráficas (/OpenGL Utility Toolkit/ - GLUT, /Simple DirectMedia Layer/ - SDL, /Simple and Fast Multimedia Library/ - SMFL o /Graphics Library Framework/ - GLFW), que deben ser implementadas conforme a las especificaciones de OpenGL. Esto ha llevado a que la implementación de OpenGL pueda tener comportamientos extraños debido a incompatibilidades con algunas tarjetas gráficas o la falta de mantenimiento de ciertas librerías por parte de sus desarrolladores.

GLFW (/Graphics Library Framework/) es una pequeña librería en C que permite la creación y gestión de ventanas con contextos OpenGL, haciendo posible también el uso de múltiples monitores y modos de vídeo. Proporciona acceso a la entrada del teclado, ratón y joysticks. La API proporciona una fina capa de abstracción multiplataforma, principalmente para aplicaciones cuya única salida gráfica es a través de la API OpenGL. Aunque GLFW es muy útil cuando se desarrollan aplicaciones OpenGL multiplataforma, los desarrolladores de una sola plataforma también pueden beneficiarse de su uso al evitar tener que lidiar con diferentes API específicas de la plataforma.

En este proyecto se utiliza la librería GLFW debido a la disponibilidad de gran cantidad y calidad de recursos didácticos que utilizan esta librería como ejemplo para desarrollar sus implementaciones de los conceptos de OpenGL, que se ha tenido que investigar desde cero para la realización de un muestreo de resultados inicial.

* Estructura del simulador y resultados
** Introducción

A lo largo de los capítulos anteriores hemos introducido el ámbito de las computer graphics, su importancia en diferentes industrias y cómo es un importante campo de investigación, se ha realizado un análisis previo desde el punto de vista de un desarrollador para dar una visión clara del proyecto que se quiere implementar. En nuestro caso, una simulación de fluidos basada en física, donde se ha hecho un recorrido por los fundamentos matemáticos necesarios y técnicas para ser capaz de simular un fluido de manera realista y versátil, siempre mencionando a los autores que avalan estas técnicas y, finalmente, se ha escogido uno en concreto. Igualmente, se ha explicado el concepto de la búsqueda de vecinas, sin el cual no se puede realizar el método de simulación escogido, junto con los diferentes tipos de búsqueda existentes y el motivo por el cual se ha seleccionado uno sobre otro. También, se ha dado una explicación general sobre los métodos de integración temporal y la razón por la que se necesitan en un campo como la simulación por ordenador. Del mismo modo, se ha establecido la importancia de que nuestro fluido sea capaz de reaccionar ante sólidos rígidos para que éste cumpla con los requisitos de versatilidad, así como las diferentes técnicas que podemos implementar para desarrollarlos. Por ultimo, se han explicado las diferentes herramientas que se han utilizado en el desarrollo de este proyecto y qué características presentan para ser preferidas frente a otras herramientas similares.

Después de haber explicado todos los pormenores que conlleva la realización de un simulador de fluidos basado en física, y comprender todas las piezas necesarias para construirlo, en este capítulo vamos a explicar cómo se ha llevado a cabo este desarrollo y la estructura interna que tiene el simulador.

** Diagrama de Clases

Debido a las peculiaridades que tiene el lenguaje CUDA C, alcanza su máximo rendimiento al no usar una estructura orientada a objetos por ello no podemos hablar de un diagrama de clases al uso ya que no vamos a trabajar con clases, pero debido a que seguimos necesitando almacenar información en el simulador vamos a representar sus funciones y variables más importantes como pseudo-clases, junto con los tipos de datos que se ingresan y devuelven.

- /Partícula/: Es una estructura (/struct/) que nos almacena la posición, velocidad, aceleración y masa de cada partícula, además de almacenar la fuerza interna, un indicador de si ha colisionado junto con un array de vecinas y su número.

- /Esfera/: Es una estructura (/struct/) en el que guardamos la posición y radio de la esfera.

- /Caja/: Es una estructura (/struct/) en la que guardamos los limites que definen a un hexaedro regular y su posición.

- /Cilindro/: Es una estructura (/struct/) en la que guardamos el eje y limite que definen un cilindro junto con su posición.

- /Modelo/: Es una estructura (/struct/) que nos almacena modelos formados por triángulos, guardando sus vértices, aristas y normales.

- /MetodoEulerSemImplcito/: Este es el método encargado de recalcular las nuevas velocidades y posiciones del conjunto de partículas que recibe, a través de la aceleración y el paso del tiempo. Al ser una función kernel cuyo objetivo es que se ejecute en el device, es necesario que previamente se reserve un espacio de memoria en la GPU para que este se	 pueda ejecutar en paralelo.

- /respuestaColision/: Este el método que dada una partícula y un vector normal calcula la posición y velocidad rectificadas.

- /detectaColisionCilindro/: Este es el método que dado un /struct/ cilindro determina a través de las operaciones vectoriales mencionadas en el capítulo [[*Colisiones]] si existe o no colisión con un cilindro y modifica el estado de colisión del conjunto de partículas recibidas.

- /detectaColisionEsfera/: Este es el método que dado un struct esfera determina a través de las operaciones vectoriales mencionados en el capítulo [[*Colisiones]] si existe o no colisión con una esfera y modifica el estado de colisión del conjunto de partículas recibidas.

- /detectaColisionCaja/: Este es el método que dado un struct caja determina a través de las operaciones vectoriales mencionados en el capítulo [[*Colisiones]] si existe o no colisión con una caja y modifica el estado de colisión del conjunto de partículas recibidas.

- /detectaColisionModelo/: Este es el método que dado un struct modelo determina a través de las operaciones vectoriales mencionados en el capítulo [[*Colisiones]] si existe o no colisión con un modelo formado por triángulos y modifica el estado de colisión del conjunto de partículas recibidas

- /vecinasFuerzaBruta/: Este es el método que determina las partículas vecinas que tiene cada partícula recorriendo todas las partículas existentes en la simulación. Modifica los atributos del conjunto de partículas y almacena en ellas el número de partículas vecinas de cada una.

- /vecinasHash/: Este es el método que determina las partículas vecinas usando la búsqueda de vecinas basada en hash explicada en el capítulo [[*Método de integración temporal]]. Modifica los atributos del conjunto de partículas y almacena en ellas el número de partículas vecinas de cada una.

- /fuerzaMuelle/: Este es el método que calcula las fuerzas internas de cada partícula basándose en la ecuación de la fuerza del muelle. Modifica las fuerzas internas del conjunto de partículas.

- /FuncionKernel/: Calculo de la función kernel vista en el capitulo [[*Fundamentos del Método SPH]].

- /GradienteKernel/: Calculo del gradiente del kernel visto en el capitulo  [[*Fundamentos del Método SPH]].

- /LaplacianoKernel/: Calculo del Laplaciano del kernel visto en el capitulo  [[*Fundamentos del Método SPH]].

- /Densidad/: Este es el método que determina la densidad del conjunto de partículas

- /fuerzaSPH/: Este es el método que calcula las fuerzas internas resultantes de aplicar el método SPH. Determina las fuerzas internas del conjunto de partículas.

- /newAcceleration/: Determina a través de las fuerzas internas, externas y la masa la nueva aceleración o cinemática de cada partícula.

- /exportador/: Dado un conjunto de partículas exporta sus atributos en archivos binarios entendibles por motores de renderizado.

** Bucle de simulación
** Resultados obtenidos
*** Comparativa en tiempo de renderizado
* Conclusiones y trabajo futuro
* Referencias                                                        :ignore:
#+print_bibliography:
